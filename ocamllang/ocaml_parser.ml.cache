open Base

#22 "ocaml_parser.trx"

open Ocaml
open Printf

let make_app l =
  assert(List.length l >= 2);
  let rec aux r = function
  | [] -> assert false
  | [hd] -> App (r, hd)
  | hd::tl -> aux (App (r, hd)) tl
  in aux (List.hd l) (List.tl l);;


#231 "ocaml_parser.trx"
 let make_fun e = function | [] -> e | x -> Abs (x, e) 

#39 "ocaml_types.trx"

open Base
open Ocaml


#48 "ocaml_types.trx"
 let compute_vars = function None -> [] | Some l -> List.map (function TypeVar s -> s | _ -> assert false) l
let _grammar_rules = [ ("Ocaml_types_typevars", None) ; ("Ocaml_types_typevarorname", None) ; ("Ocaml_types_typevar", None) ; ("Ocaml_types_typerecord_aux", None) ; ("Ocaml_types_typerecord", None) ; ("Ocaml_types_typeparam", None) ; ("Ocaml_types_typename", None) ; ("Ocaml_types_typefinder", None) ; ("Ocaml_types_typedeflist", None) ; ("Ocaml_types_typedef_no_arrow", None) ; ("Ocaml_types_typedef_base", None) ; ("Ocaml_types_typedef_aux", None) ; ("Ocaml_types_typedef", None) ; ("Ocaml_types_typedeclaration", None) ; ("Ocaml_types_typeconstructor", None) ; ("Ocaml_types_typeconst", None) ; ("Ocaml_types_typeSum", None) ; ("Ocaml_types_typeIdent_cont", None) ; ("Ocaml_types_typeIdent_aux", None) ; ("Ocaml_types_typeIdent", None) ; ("Ocaml_types_test", None) ; ("Ocaml_types_spacing", None) ; ("Ocaml_types_onetyperecord", None) ; ("Ocaml_types_lineskipper", None) ; ("Ocaml_types_UnitT", None) ; ("Ocaml_types_StringT", None) ; ("Ocaml_types_IntT", None) ; ("Ocaml_types_Int64T", None) ; ("Ocaml_types_FloatT", None) ; ("Ocaml_types_CharT", None) ; ("Ocaml_types_BoolT", None) ; ("Ocaml_parser_unit", None) ; ("Ocaml_parser_type", None) ; ("Ocaml_parser_spacing", None) ; ("Ocaml_parser_pattern_cons", None) ; ("Ocaml_parser_pattern_aux_l", None) ; ("Ocaml_parser_pattern_aux_aux", None) ; ("Ocaml_parser_pattern_aux", None) ; ("Ocaml_parser_pattern", None) ; ("Ocaml_parser_parse", None) ; ("Ocaml_parser_paramFormel", None) ; ("Ocaml_parser_paramEffectif", None) ; ("Ocaml_parser_op_special", None) ; ("Ocaml_parser_op_or", None) ; ("Ocaml_parser_op_notequal_struct", None) ; ("Ocaml_parser_op_notequal", None) ; ("Ocaml_parser_op_logic", None) ; ("Ocaml_parser_op_equal_struct", None) ; ("Ocaml_parser_op_equal", None) ; ("Ocaml_parser_op_concat", None) ; ("Ocaml_parser_op_aro", None) ; ("Ocaml_parser_op_and", None) ; ("Ocaml_parser_moduleName_", None) ; ("Ocaml_parser_moduleName", None) ; ("Ocaml_parser_mlIdent_cont", None) ; ("Ocaml_parser_mlIdent_aux_", None) ; ("Ocaml_parser_mlIdent_aux", None) ; ("Ocaml_parser_mlIdent_", None) ; ("Ocaml_parser_mlIdent", None) ; ("Ocaml_parser_matchExpr", None) ; ("Ocaml_parser_emptylist", None) ; ("Ocaml_parser_dotable", None) ; ("Ocaml_parser_constructorName", None) ; ("Ocaml_parser_const", None) ; ("Ocaml_parser_capMlIdent_", None) ; ("Ocaml_parser_capMlIdent", None) ; ("Ocaml_parser_Var", None) ; ("Ocaml_parser_Type", None) ; ("Ocaml_parser_Try", None) ; ("Ocaml_parser_SimpleExpr", None) ; ("Ocaml_parser_SetRef", None) ; ("Ocaml_parser_Record", None) ; ("Ocaml_parser_Raise", None) ; ("Ocaml_parser_RNameOpt", None) ; ("Ocaml_parser_Paren", None) ; ("Ocaml_parser_PLUS", None) ; ("Ocaml_parser_Operators", None) ; ("Ocaml_parser_Open", None) ; ("Ocaml_parser_OpLevel4", None) ; ("Ocaml_parser_OpLevel3", None) ; ("Ocaml_parser_OpLevel2", None) ; ("Ocaml_parser_OpLevel1", None) ; ("Ocaml_parser_Module", None) ; ("Ocaml_parser_Match", None) ; ("Ocaml_parser_MakeRef", None) ; ("Ocaml_parser_MULT", None) ; ("Ocaml_parser_MINUS", None) ; ("Ocaml_parser_Letin", None) ; ("Ocaml_parser_LetOrType", None) ; ("Ocaml_parser_Let", None) ; ("Ocaml_parser_LT", None) ; ("Ocaml_parser_LE", None) ; ("Ocaml_parser_InfOpLevel4", None) ; ("Ocaml_parser_InfOpLevel3", None) ; ("Ocaml_parser_InfOpLevel2", None) ; ("Ocaml_parser_InfOpLevel1", None) ; ("Ocaml_parser_IPLUS", None) ; ("Ocaml_parser_IMULT", None) ; ("Ocaml_parser_IMINUS", None) ; ("Ocaml_parser_IDIV", None) ; ("Ocaml_parser_GetRef", None) ; ("Ocaml_parser_GT", None) ; ("Ocaml_parser_GE", None) ; ("Ocaml_parser_FPLUS", None) ; ("Ocaml_parser_FMULT", None) ; ("Ocaml_parser_FMINUS", None) ; ("Ocaml_parser_FDIV", None) ; ("Ocaml_parser_Expr_without_seq_aux", None) ; ("Ocaml_parser_Expr_without_seq", None) ; ("Ocaml_parser_ExprNotApp", None) ; ("Ocaml_parser_Expr", None) ; ("Ocaml_parser_Exception", None) ; ("Ocaml_parser_EmptyList", None) ; ("Ocaml_parser_Dot", None) ; ("Ocaml_parser_DIV", None) ; ("Ocaml_parser_Constructor", None) ; ("Ocaml_parser_Const", None) ; ("Ocaml_parser_Cons", None) ; ("Ocaml_parser_Cond", None) ; ("Ocaml_parser_Assert", None) ; ("Ocaml_parser_App", None) ; ("Ocaml_parser_Abs", None) ; ("Ocaml_keywords_spacing", None) ; ("Ocaml_keywords_WITH", None) ; ("Ocaml_keywords_WHEN", None) ; ("Ocaml_keywords_VAL", None) ; ("Ocaml_keywords_TYPE", None) ; ("Ocaml_keywords_TRY", None) ; ("Ocaml_keywords_TRUE", None) ; ("Ocaml_keywords_THEN", None) ; ("Ocaml_keywords_STRUCT", None) ; ("Ocaml_keywords_SPECIALS", None) ; ("Ocaml_keywords_SIG", None) ; ("Ocaml_keywords_REF", None) ; ("Ocaml_keywords_REC", None) ; ("Ocaml_keywords_RAISE", None) ; ("Ocaml_keywords_ORL", None) ; ("Ocaml_keywords_OPEN", None) ; ("Ocaml_keywords_OF", None) ; ("Ocaml_keywords_MUTABLE", None) ; ("Ocaml_keywords_MODULE", None) ; ("Ocaml_keywords_MATCH", None) ; ("Ocaml_keywords_LET", None) ; ("Ocaml_keywords_KEYWORDS", None) ; ("Ocaml_keywords_IN", None) ; ("Ocaml_keywords_IF", None) ; ("Ocaml_keywords_GETREF", None) ; ("Ocaml_keywords_FUNCTION", None) ; ("Ocaml_keywords_FUN", None) ; ("Ocaml_keywords_FALSE", None) ; ("Ocaml_keywords_EXCEPTION", None) ; ("Ocaml_keywords_END", None) ; ("Ocaml_keywords_ELSE", None) ; ("Ocaml_keywords_CONSTRUCTOR_aux", None) ; ("Ocaml_keywords_CONSTRUCTOR", None) ; ("Ocaml_keywords_CONS", None) ; ("Ocaml_keywords_BEGIN", None) ; ("Ocaml_keywords_ASSERT", None) ; ("Ocaml_keywords_AS", None) ; ("Ocaml_keywords_ANDL", None) ; ("Ocaml_keywords_AND", None) ; ("Default_underscore", None) ; ("Default_times", None) ; ("Default_tilde_", None) ; ("Default_strint64", None) ; ("Default_strint", None) ; ("Default_stringsinglequote", None) ; ("Default_stringsinglechar", None) ; ("Default_stringquote", None) ; ("Default_stringnosp", None) ; ("Default_stringcharspecial", None) ; ("Default_stringchar", None) ; ("Default_string", None) ; ("Default_strfloat", None) ; ("Default_strbool", None) ; ("Default_str_ipaddr", None) ; ("Default_spacing", None) ; ("Default_space", None) ; ("Default_slash", None) ; ("Default_singlequotechar_", None) ; ("Default_sharpcomment", None) ; ("Default_sharp", None) ; ("Default_semi", None) ; ("Default_rparen", None) ; ("Default_rightarrow", None) ; ("Default_rbracket", None) ; ("Default_raccol", None) ; ("Default_question_", None) ; ("Default_question", None) ; ("Default_plus", None) ; ("Default_parexprnosp", None) ; ("Default_parexprexcluded", None) ; ("Default_parexpr", None) ; ("Default_mlcomment", None) ; ("Default_mlCOMMENTSTOP", None) ; ("Default_mlCOMMENTSTART", None) ; ("Default_lparen", None) ; ("Default_leftarrow", None) ; ("Default_lbracket", None) ; ("Default_laccol", None) ; ("Default_int64", None) ; ("Default_int3", None) ; ("Default_int", None) ; ("Default_humanint", None) ; ("Default_hexa", None) ; ("Default_float", None) ; ("Default_equal", None) ; ("Default_eol", None) ; ("Default_eof", None) ; ("Default_dot", None) ; ("Default_comma", None) ; ("Default_colon", None) ; ("Default_charsinglequote", None) ; ("Default_bracketexprcontent", None) ; ("Default_bracketexpr", None) ; ("Default_bool", None) ; ("Default_bar", None) ; ("Default_bang", None) ; ("Default_at", None) ; ("Default_accolexprcontent", None) ; ("Default_accolexpr", None) ]
let parse_with f_noerr f_err _text _start = let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (f_noerr (_text) (_start)) with
Some ( ( pos, res ) ) -> (pos, res)
| None -> (match (f_err (_text) (_start)) with
Trx_runtime.Ok ( ( ( _, _ ), _ ) ) -> (assert false)
| Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.gen_syntax_error (((FilePos.get_pos_no_cache) (_text))) (err))))
let memo_Default_bar = ((Hashtbl.create) (128))
let memo_Default_bar_err = ((Hashtbl.create) (128))
let memo_Default_charsinglequote = ((Hashtbl.create) (128))
let memo_Default_charsinglequote_err = ((Hashtbl.create) (128))
let memo_Default_colon = ((Hashtbl.create) (128))
let memo_Default_colon_err = ((Hashtbl.create) (128))
let memo_Default_comma = ((Hashtbl.create) (128))
let memo_Default_comma_err = ((Hashtbl.create) (128))
let memo_Default_dot = ((Hashtbl.create) (128))
let memo_Default_dot_err = ((Hashtbl.create) (128))
let memo_Default_equal = ((Hashtbl.create) (128))
let memo_Default_equal_err = ((Hashtbl.create) (128))
let memo_Default_float = ((Hashtbl.create) (128))
let memo_Default_float_err = ((Hashtbl.create) (128))
let memo_Default_int = ((Hashtbl.create) (128))
let memo_Default_int_err = ((Hashtbl.create) (128))
let memo_Default_laccol = ((Hashtbl.create) (128))
let memo_Default_laccol_err = ((Hashtbl.create) (128))
let memo_Default_lbracket = ((Hashtbl.create) (128))
let memo_Default_lbracket_err = ((Hashtbl.create) (128))
let memo_Default_leftarrow = ((Hashtbl.create) (128))
let memo_Default_leftarrow_err = ((Hashtbl.create) (128))
let memo_Default_lparen = ((Hashtbl.create) (128))
let memo_Default_lparen_err = ((Hashtbl.create) (128))
let memo_Default_mlcomment = ((Hashtbl.create) (128))
let memo_Default_mlcomment_err = ((Hashtbl.create) (128))
let memo_Default_question = ((Hashtbl.create) (128))
let memo_Default_question_err = ((Hashtbl.create) (128))
let memo_Default_raccol = ((Hashtbl.create) (128))
let memo_Default_raccol_err = ((Hashtbl.create) (128))
let memo_Default_rbracket = ((Hashtbl.create) (128))
let memo_Default_rbracket_err = ((Hashtbl.create) (128))
let memo_Default_rightarrow = ((Hashtbl.create) (128))
let memo_Default_rightarrow_err = ((Hashtbl.create) (128))
let memo_Default_rparen = ((Hashtbl.create) (128))
let memo_Default_rparen_err = ((Hashtbl.create) (128))
let memo_Default_semi = ((Hashtbl.create) (128))
let memo_Default_semi_err = ((Hashtbl.create) (128))
let memo_Default_singlequotechar_ = ((Hashtbl.create) (128))
let memo_Default_singlequotechar__err = ((Hashtbl.create) (128))
let memo_Default_spacing = ((Hashtbl.create) (128))
let memo_Default_spacing_err = ((Hashtbl.create) (128))
let memo_Default_strfloat = ((Hashtbl.create) (128))
let memo_Default_strfloat_err = ((Hashtbl.create) (128))
let memo_Default_string = ((Hashtbl.create) (128))
let memo_Default_string_err = ((Hashtbl.create) (128))
let memo_Default_stringchar = ((Hashtbl.create) (128))
let memo_Default_stringchar_err = ((Hashtbl.create) (128))
let memo_Default_stringcharspecial = ((Hashtbl.create) (128))
let memo_Default_stringcharspecial_err = ((Hashtbl.create) (128))
let memo_Default_stringnosp = ((Hashtbl.create) (128))
let memo_Default_stringnosp_err = ((Hashtbl.create) (128))
let memo_Default_strint = ((Hashtbl.create) (128))
let memo_Default_strint_err = ((Hashtbl.create) (128))
let memo_Default_underscore = ((Hashtbl.create) (128))
let memo_Default_underscore_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AND = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AND_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ASSERT = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ASSERT_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_BEGIN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_BEGIN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_CONS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_CONS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ELSE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ELSE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_END = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_END_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_EXCEPTION = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_EXCEPTION_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUNCTION = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUNCTION_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_GETREF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_GETREF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_KEYWORDS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_KEYWORDS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_LET = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_LET_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MATCH = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MATCH_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MODULE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MODULE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MUTABLE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MUTABLE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OPEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OPEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_RAISE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_RAISE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REC = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REC_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_SPECIALS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_SPECIALS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_STRUCT = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_STRUCT_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_THEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_THEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TRY = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TRY_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TYPE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TYPE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WHEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WHEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WITH = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WITH_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Abs = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Abs_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_App = ((Hashtbl.create) (128))
let memo_Ocaml_parser_App_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Assert = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Assert_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cond = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cond_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cons = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cons_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Const = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Const_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Constructor = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Constructor_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_DIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_DIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Dot = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Dot_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_EmptyList = ((Hashtbl.create) (128))
let memo_Ocaml_parser_EmptyList_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Exception = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Exception_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_ExprNotApp = ((Hashtbl.create) (128))
let memo_Ocaml_parser_ExprNotApp_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FDIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FDIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FPLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FPLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GE = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GE_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GetRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GetRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IDIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IDIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IPLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IPLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel1 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel1_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel2 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel2_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel3 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel3_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel4 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel4_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LE = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LE_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Let = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Let_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LetOrType = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LetOrType_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Letin = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Letin_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MakeRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MakeRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Match = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Match_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Module = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Module_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel1 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel1_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel2 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel2_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel3 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel3_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel4 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel4_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Open = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Open_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_PLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_PLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Paren = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Paren_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_RNameOpt = ((Hashtbl.create) (128))
let memo_Ocaml_parser_RNameOpt_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Raise = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Raise_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Record = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Record_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SetRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SetRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SimpleExpr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SimpleExpr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Try = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Try_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Type = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Type_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Var = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Var_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_const = ((Hashtbl.create) (128))
let memo_Ocaml_parser_const_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_constructorName = ((Hashtbl.create) (128))
let memo_Ocaml_parser_constructorName_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_dotable = ((Hashtbl.create) (128))
let memo_Ocaml_parser_dotable_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_emptylist = ((Hashtbl.create) (128))
let memo_Ocaml_parser_emptylist_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_matchExpr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_matchExpr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_and = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_and_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_aro = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_aro_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_concat = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_concat_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_struct = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_struct_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_logic = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_logic_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_struct = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_struct_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_or = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_or_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_special = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_special_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramEffectif = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramEffectif_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramFormel = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramFormel_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_parse = ((Hashtbl.create) (128))
let memo_Ocaml_parser_parse_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_l = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_l_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_cons = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_cons_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_parser_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_type = ((Hashtbl.create) (128))
let memo_Ocaml_parser_type_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_unit = ((Hashtbl.create) (128))
let memo_Ocaml_parser_unit_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_lineskipper = ((Hashtbl.create) (128))
let memo_Ocaml_types_lineskipper_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_onetyperecord = ((Hashtbl.create) (128))
let memo_Ocaml_types_onetyperecord_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_types_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_test = ((Hashtbl.create) (128))
let memo_Ocaml_types_test_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeSum = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeSum_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconst = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconst_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconstructor = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconstructor_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeclaration = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeclaration_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_base = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_base_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_no_arrow = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_no_arrow_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeflist = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeflist_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typefinder = ((Hashtbl.create) (128))
let memo_Ocaml_types_typefinder_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typename = ((Hashtbl.create) (128))
let memo_Ocaml_types_typename_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeparam = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeparam_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevar = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevar_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevarorname = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevarorname_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevars = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevars_err = ((Hashtbl.create) (128))
let prepare_cache () = ((Hashtbl.clear) (memo_Default_bar)) ; ((Hashtbl.clear) (memo_Default_bar_err)) ; ((Hashtbl.clear) (memo_Default_charsinglequote)) ; ((Hashtbl.clear) (memo_Default_charsinglequote_err)) ; ((Hashtbl.clear) (memo_Default_colon)) ; ((Hashtbl.clear) (memo_Default_colon_err)) ; ((Hashtbl.clear) (memo_Default_comma)) ; ((Hashtbl.clear) (memo_Default_comma_err)) ; ((Hashtbl.clear) (memo_Default_dot)) ; ((Hashtbl.clear) (memo_Default_dot_err)) ; ((Hashtbl.clear) (memo_Default_equal)) ; ((Hashtbl.clear) (memo_Default_equal_err)) ; ((Hashtbl.clear) (memo_Default_float)) ; ((Hashtbl.clear) (memo_Default_float_err)) ; ((Hashtbl.clear) (memo_Default_int)) ; ((Hashtbl.clear) (memo_Default_int_err)) ; ((Hashtbl.clear) (memo_Default_laccol)) ; ((Hashtbl.clear) (memo_Default_laccol_err)) ; ((Hashtbl.clear) (memo_Default_lbracket)) ; ((Hashtbl.clear) (memo_Default_lbracket_err)) ; ((Hashtbl.clear) (memo_Default_leftarrow)) ; ((Hashtbl.clear) (memo_Default_leftarrow_err)) ; ((Hashtbl.clear) (memo_Default_lparen)) ; ((Hashtbl.clear) (memo_Default_lparen_err)) ; ((Hashtbl.clear) (memo_Default_mlcomment)) ; ((Hashtbl.clear) (memo_Default_mlcomment_err)) ; ((Hashtbl.clear) (memo_Default_question)) ; ((Hashtbl.clear) (memo_Default_question_err)) ; ((Hashtbl.clear) (memo_Default_raccol)) ; ((Hashtbl.clear) (memo_Default_raccol_err)) ; ((Hashtbl.clear) (memo_Default_rbracket)) ; ((Hashtbl.clear) (memo_Default_rbracket_err)) ; ((Hashtbl.clear) (memo_Default_rightarrow)) ; ((Hashtbl.clear) (memo_Default_rightarrow_err)) ; ((Hashtbl.clear) (memo_Default_rparen)) ; ((Hashtbl.clear) (memo_Default_rparen_err)) ; ((Hashtbl.clear) (memo_Default_semi)) ; ((Hashtbl.clear) (memo_Default_semi_err)) ; ((Hashtbl.clear) (memo_Default_singlequotechar_)) ; ((Hashtbl.clear) (memo_Default_singlequotechar__err)) ; ((Hashtbl.clear) (memo_Default_spacing)) ; ((Hashtbl.clear) (memo_Default_spacing_err)) ; ((Hashtbl.clear) (memo_Default_strfloat)) ; ((Hashtbl.clear) (memo_Default_strfloat_err)) ; ((Hashtbl.clear) (memo_Default_string)) ; ((Hashtbl.clear) (memo_Default_string_err)) ; ((Hashtbl.clear) (memo_Default_stringchar)) ; ((Hashtbl.clear) (memo_Default_stringchar_err)) ; ((Hashtbl.clear) (memo_Default_stringcharspecial)) ; ((Hashtbl.clear) (memo_Default_stringcharspecial_err)) ; ((Hashtbl.clear) (memo_Default_stringnosp)) ; ((Hashtbl.clear) (memo_Default_stringnosp_err)) ; ((Hashtbl.clear) (memo_Default_strint)) ; ((Hashtbl.clear) (memo_Default_strint_err)) ; ((Hashtbl.clear) (memo_Default_underscore)) ; ((Hashtbl.clear) (memo_Default_underscore_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AND)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AND_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ASSERT)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ASSERT_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_BEGIN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_BEGIN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_CONS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_CONS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ELSE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ELSE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_END)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_END_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_EXCEPTION)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_EXCEPTION_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUNCTION)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUNCTION_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_GETREF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_GETREF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_KEYWORDS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_KEYWORDS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_LET)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_LET_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MATCH)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MATCH_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MODULE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MODULE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MUTABLE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MUTABLE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OPEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OPEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_RAISE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_RAISE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REC)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REC_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_SPECIALS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_SPECIALS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_STRUCT)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_STRUCT_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_THEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_THEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TRY)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TRY_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TYPE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TYPE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WHEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WHEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WITH)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WITH_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Abs)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Abs_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_App)) ; ((Hashtbl.clear) (memo_Ocaml_parser_App_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Assert)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Assert_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cond)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cond_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cons)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cons_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Const)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Const_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Constructor)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Constructor_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_DIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_DIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Dot)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Dot_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_EmptyList)) ; ((Hashtbl.clear) (memo_Ocaml_parser_EmptyList_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Exception)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Exception_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_ExprNotApp)) ; ((Hashtbl.clear) (memo_Ocaml_parser_ExprNotApp_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FDIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FDIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FPLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FPLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GE)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GE_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GetRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GetRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IDIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IDIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IPLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IPLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel1)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel1_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel2)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel2_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel3)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel3_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel4)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel4_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LE)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LE_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Let)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Let_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LetOrType)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LetOrType_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Letin)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Letin_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MakeRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MakeRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Match)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Match_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Module)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Module_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel1)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel1_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel2)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel2_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel3)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel3_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel4)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel4_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Open)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Open_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_PLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_PLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Paren)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Paren_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_RNameOpt)) ; ((Hashtbl.clear) (memo_Ocaml_parser_RNameOpt_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Raise)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Raise_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Record)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Record_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SetRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SetRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SimpleExpr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SimpleExpr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Try)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Try_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Type)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Type_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Var)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Var_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_const)) ; ((Hashtbl.clear) (memo_Ocaml_parser_const_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_constructorName)) ; ((Hashtbl.clear) (memo_Ocaml_parser_constructorName_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_dotable)) ; ((Hashtbl.clear) (memo_Ocaml_parser_dotable_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_emptylist)) ; ((Hashtbl.clear) (memo_Ocaml_parser_emptylist_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_matchExpr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_matchExpr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_and)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_and_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_aro)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_aro_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_concat)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_concat_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_struct)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_struct_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_logic)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_logic_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_struct)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_struct_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_or)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_or_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_special)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_special_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramEffectif)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramEffectif_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramFormel)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramFormel_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_parse)) ; ((Hashtbl.clear) (memo_Ocaml_parser_parse_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_l)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_l_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_cons)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_cons_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_parser_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_type)) ; ((Hashtbl.clear) (memo_Ocaml_parser_type_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_unit)) ; ((Hashtbl.clear) (memo_Ocaml_parser_unit_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_lineskipper)) ; ((Hashtbl.clear) (memo_Ocaml_types_lineskipper_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_onetyperecord)) ; ((Hashtbl.clear) (memo_Ocaml_types_onetyperecord_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_types_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_test)) ; ((Hashtbl.clear) (memo_Ocaml_types_test_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeSum)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeSum_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconst)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconst_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconstructor)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconstructor_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeclaration)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeclaration_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_base)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_base_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_no_arrow)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_no_arrow_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeflist)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeflist_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typefinder)) ; ((Hashtbl.clear) (memo_Ocaml_types_typefinder_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typename)) ; ((Hashtbl.clear) (memo_Ocaml_types_typename_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeparam)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeparam_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevar)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevar_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevarorname)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevarorname_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevars)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevars_err))
let rec try_Default_mlCOMMENTSTART = 
#102 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "(*")) ) else ( None )) (input) ("\"(*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1843, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1843, ( () )), ((Trx_runtime.emptyError) (input_1843))))))))
let rec try_Default_mlCOMMENTSTOP = 
#103 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*)")) ) else ( None )) (input) ("\"*)\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1842, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1842, ( () )), ((Trx_runtime.emptyError) (input_1842))))))))
let rec try_Default_mlcomment = 
#101 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_mlcomment_err) (input))
) with
Not_found -> let res = (match (try_Default_mlCOMMENTSTART (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1834, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1837 -> (match (try_Default_mlCOMMENTSTOP (_filename) (_text) (input_1837)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1838 = input_1837 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_mlcomment (_filename) (_text) (input_1838)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1841, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1841, __1), ((Trx_runtime.emptyError) (input_1841))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1838) (_len)) ) then ( let c = ((_get_char) (input_1838)) in
Some((((succ) (input_1838)), c)) ) else ( None )) (input_1838) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1840, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1840, ( () )), ((Trx_runtime.emptyError) (input_1840)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1839, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1839, __2), ((Trx_runtime.emptyError) (input_1839)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_1834)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1835, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlCOMMENTSTOP (_filename) (_text) (input_1835)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1836, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1836, ( () )), ((Trx_runtime.emptyError) (input_1836))))))))))))) in
(Hashtbl.add (memo_Default_mlcomment_err) (input) (res)) ; res)
)
let rec try_Default_space = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\t'")) ; Trx_runtime.Expected(("'\n'")) ; Trx_runtime.Expected(("'\r'")) ; Trx_runtime.Expected(("' '")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1783, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1783, __1), ((Trx_runtime.emptyError) (input_1783))))))))
let rec try_Ocaml_parser_spacing = 
#35 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1106 -> (match (match (try_Default_space (_filename) (_text) (input_1106)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1108, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1108, ( () )), ((Trx_runtime.emptyError) (input_1108))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1106)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1107, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1107, __1), ((Trx_runtime.emptyError) (input_1107)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1105, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1105, ( () )), ((Trx_runtime.emptyError) (input_1105))))))) in
(Hashtbl.add (memo_Ocaml_parser_spacing_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_equal_struct = 
#383 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_struct_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "==")) ) else ( None )) (input) ("\"==\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1246, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1246)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1247, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1247, 
#383 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1247)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_struct_err) (input) (res)) ; res)
)
let rec try_Default_mlCOMMENTSTART_noerr = 
#102 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "(*")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_889, __1 ) ) -> Some((input_889, ( () )))))
let rec try_Default_mlCOMMENTSTOP_noerr = 
#103 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*)")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_888, __1 ) ) -> Some((input_888, ( () )))))
let rec try_Default_mlcomment_noerr = 
#101 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_mlcomment) (input))
) with
Not_found -> let res = (match (try_Default_mlCOMMENTSTART_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_880, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_883 -> (match (try_Default_mlCOMMENTSTOP_noerr (_filename) (_text) (input_883)) with
None -> let input_884 = input_883 in
let __1 = () in
(match (try_Default_mlcomment_noerr (_filename) (_text) (input_884)) with
None -> (match if ( (((<)) (input_884) (_len)) ) then ( let c = ((_get_char) (input_884)) in
Some((((succ) (input_884)), c)) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_886, __1 ) ) -> Some((input_886, ( () ))))
| ( _ok ) as __pat_var -> __pat_var)
| Some ( ( _, _ ) ) -> None))) (input_880)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_881, __2 ) ) -> (match (try_Default_mlCOMMENTSTOP_noerr (_filename) (_text) (input_881)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_882, __3 ) ) -> Some((input_882, ( () )))))) in
(Hashtbl.add (memo_Default_mlcomment) (input) (res)) ; res)
)
let rec try_Default_space_noerr = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Default_spacing_noerr = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_826 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_826)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_828, __1 ) ) -> Some((input_828, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_826))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_825, __1 ) ) -> Some((input_825, ( () )))) in
(Hashtbl.add (memo_Default_spacing) (input) (res)) ; res)
)
let rec try_Default_bar_noerr = 
#80 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_bar) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('|')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_940, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_940)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_941, __2 ) ) -> Some((input_941, ( () ))))) in
(Hashtbl.add (memo_Default_bar) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_spacing_noerr = 
#20 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_685 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_685)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_687, __1 ) ) -> Some((input_687, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_685))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_684, __1 ) ) -> Some((input_684, ( () )))) in
(Hashtbl.add (memo_Ocaml_keywords_spacing) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_FUNCTION_noerr = 
#52 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUNCTION) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_732, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_732)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_733, __2 ) ) -> Some((input_733, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUNCTION) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MATCH_noerr = 
#46 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MATCH) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_722, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_722)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_723, __2 ) ) -> Some((input_723, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MATCH) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_WITH_noerr = 
#47 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WITH) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_688, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_688)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_689, __2 ) ) -> Some((input_689, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_WITH) (input) (res)) ; res)
)
let rec try_Default_semi_noerr = 
#68 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_semi) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_843, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_843)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_844, __2 ) ) -> Some((input_844, ( () ))))) in
(Hashtbl.add (memo_Default_semi) (input) (res)) ; res)
)
let rec try_Default_comma_noerr = 
#63 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_comma) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_924, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_924)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_925, __2 ) ) -> Some((input_925, ( () ))))) in
(Hashtbl.add (memo_Default_comma) (input) (res)) ; res)
)
let rec try_Ocaml_parser_spacing_noerr = 
#35 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_152 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_152)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_154, __1 ) ) -> Some((input_154, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_152))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_151, __1 ) ) -> Some((input_151, ( () )))) in
(Hashtbl.add (memo_Ocaml_parser_spacing) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_and_noerr = 
#380 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_and) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('&'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_300, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_300)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_301, __2 ) ) -> Some((input_301, 
#380 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_and) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_or_noerr = 
#381 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_or) (input))
) with
Not_found -> let res = (match if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'|' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))) ) then ( Some(((((+)) (input) (2)), "||")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (2)), "or")) ) else ( None )
| _ -> None) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_284, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_284)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_285, __2 ) ) -> Some((input_285, 
#381 "ocaml_parser.trx"
( "||"  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_or) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel1_noerr = 
#354 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel1) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_op_and_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_op_or_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_562, __1 ) ) -> Some((input_562, 
#355 "ocaml_parser.trx"
( Ocaml.make_Var __1
   )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel1) (input) (res)) ; res)
)
let rec try_Ocaml_parser_GE_noerr = 
#396 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ">=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_577, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_577)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_578, __2 ) ) -> Some((input_578, 
#396 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GE) (input) (res)) ; res)
)
let rec try_Ocaml_parser_GT_noerr = 
#394 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) (true)))) ) then ( Some(((((+)) (input) (1)), ">")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_575, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_575)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_576, __2 ) ) -> Some((input_576, 
#394 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GT) (input) (res)) ; res)
)
let rec try_Ocaml_parser_LE_noerr = 
#395 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_541, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_541)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_542, __2 ) ) -> Some((input_542, 
#395 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_LE) (input) (res)) ; res)
)
let rec try_Ocaml_parser_LT_noerr = 
#393 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (1)), "<")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_539, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_539)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_540, __2 ) ) -> Some((input_540, 
#393 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_LT) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_equal_noerr = 
#382 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input) (1)), "=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_294, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_294)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_295, __2 ) ) -> Some((input_295, 
#382 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_equal_struct_noerr = 
#383 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_struct) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "==")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_292, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_292)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_293, __2 ) ) -> Some((input_293, 
#383 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_struct) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_notequal_noerr = 
#385 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<>")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_288, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_288)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_289, __2 ) ) -> Some((input_289, 
#385 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_notequal_struct_noerr = 
#384 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_struct) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "!=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_286, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_286)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_287, __2 ) ) -> Some((input_287, 
#384 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_struct) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_SPECIALS_noerr = 
#39 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_SPECIALS) (input))
) with
Not_found -> let res = if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'm' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "mod")) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None ) in
(Hashtbl.add (memo_Ocaml_keywords_SPECIALS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_special_noerr = 
#391 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_special) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_SPECIALS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_282, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_282)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_283, __2 ) ) -> Some((input_283, 
#391 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_special) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel2_noerr = 
#359 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel2) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_op_equal_struct_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_equal_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_notequal_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_notequal_struct_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_LE_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_GE_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_LT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_GT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_553, __1 ) ) -> Some((input_553, 
#361 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) with
None -> (match (try_Ocaml_parser_op_special_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_552, __1 ) ) -> Some((input_552, 
#366 "ocaml_parser.trx"
( Ocaml.make_Var __1
     ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel2) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FMINUS_noerr = 
#409 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMINUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "-.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_583, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_583)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_584, __2 ) ) -> Some((input_584, 
#409 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FMINUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IMINUS_noerr = 
#404 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMINUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (1)), "-")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_569, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_569)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_570, __2 ) ) -> Some((input_570, 
#404 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IMINUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_MINUS_noerr = 
#399 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MINUS) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FMINUS_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IMINUS_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MINUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FPLUS_noerr = 
#408 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FPLUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "+.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_579, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_579)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_580, __2 ) ) -> Some((input_580, 
#408 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FPLUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IPLUS_noerr = 
#403 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IPLUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) (true)))) ) then ( Some(((((+)) (input) (1)), "+")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_565, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_565)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_566, __2 ) ) -> Some((input_566, 
#403 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IPLUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_PLUS_noerr = 
#398 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_PLUS) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FPLUS_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IPLUS_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_PLUS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_aro_noerr = 
#388 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_aro) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('@'))) (true)))) ) then ( Some(((((+)) (input) (1)), "@")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_298, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_298)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_299, __2 ) ) -> Some((input_299, 
#388 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_aro) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_concat_noerr = 
#387 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_concat) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input) (1)), "^")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_296, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_296)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_297, __2 ) ) -> Some((input_297, 
#387 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_concat) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_logic_noerr = 
#389 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_logic) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "asr")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_290, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_290)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_291, __2 ) ) -> Some((input_291, 
#389 "ocaml_parser.trx"
( "asr"  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_logic) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel3_noerr = 
#370 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel3) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_PLUS_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_MINUS_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_concat_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_aro_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_op_logic_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_546, __1 ) ) -> Some((input_546, 
#371 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel3) (input) (res)) ; res)
)
let rec try_Default_lparen_noerr = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_890, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_890)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_891, __2 ) ) -> Some((input_891, ( () ))))) in
(Hashtbl.add (memo_Default_lparen) (input) (res)) ; res)
)
let rec try_Default_rparen_noerr = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_845, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_845)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_846, __2 ) ) -> Some((input_846, ( () ))))) in
(Hashtbl.add (memo_Default_rparen) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_CONS_noerr = 
#79 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_CONS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "::")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_750, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_750)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_751, __2 ) ) -> Some((input_751, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_CONS) (input) (res)) ; res)
)
let rec try_Default_rightarrow_noerr = 
#86 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rightarrow) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "->")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_847, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_847)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_848, __2 ) ) -> Some((input_848, ( () ))))) in
(Hashtbl.add (memo_Default_rightarrow) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_FUN_noerr = 
#41 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "fun")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_734, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_734)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_735, __2 ) ) -> Some((input_735, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUN) (input) (res)) ; res)
)
let rec try_Default_colon_noerr = 
#67 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_colon) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_926, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_926)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_927, __2 ) ) -> Some((input_927, ( () ))))) in
(Hashtbl.add (memo_Default_colon) (input) (res)) ; res)
)
let rec try_Default_equal_noerr = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_equal) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_917, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_917)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_918, __2 ) ) -> Some((input_918, ( () ))))) in
(Hashtbl.add (memo_Default_equal) (input) (res)) ; res)
)
let rec try_Default_question_noerr = 
#76 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_question) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_854, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_854)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_855, __2 ) ) -> Some((input_855, ( () ))))) in
(Hashtbl.add (memo_Default_question) (input) (res)) ; res)
)
let rec try_Default_tilde__noerr = 
#83 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_766, __1 ) ) -> Some((input_766, ( () )))))
let rec try_Ocaml_keywords_KEYWORDS_noerr = 
#22 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_KEYWORDS) (input))
) with
Not_found -> let res = if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'~' -> Some(((((+)) (input) (1)), "~"))
| '}' -> Some(((((+)) (input) (1)), "}"))
| '|' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "||"))
| ']' -> Some(((((+)) (input) (2)), "|]"))
| _ -> Some(((((+)) (input) (1)), "|"))) ) else ( Some(((((+)) (input) (1)), "|")) )
| '{' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (2)), "{<")) ) else ( Some(((((+)) (input) (1)), "{")) )
| 'w' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )
| 'h' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (5)), "while")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'v' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "virtual")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) (true)))) ) then ( Some(((((+)) (input) (3)), "val")) ) else ( None )
| _ -> None) ) else ( None )
| 't' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'y' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )
| 'r' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'y' -> Some(((((+)) (input) (3)), "try"))
| 'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )
| _ -> None) ) else ( None )
| 'o' -> Some(((((+)) (input) (2)), "to"))
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )
| _ -> None) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) (true)))) ) then ( Some(((((+)) (input) (3)), "sig")) ) else ( None )
| _ -> None) ) else ( None )
| 'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('v'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), "private")) ) else ( None )
| 'o' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'r' -> Some(((((+)) (input) (2)), "or"))
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )
| 'f' -> Some(((((+)) (input) (2)), "of"))
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('j'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "object")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('w'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "new")) ) else ( None )
| 'm' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( Some(((((+)) (input) (3)), "mod")) ) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "method")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )
| _ -> None) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'z' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('y'))) (true)))) ) then ( Some(((((+)) (input) (4)), "lazy")) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'i' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'n' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (11))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('z'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (10))))) ('r'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (11)), "initializer")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "inherit")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "include")) ) else ( Some(((((+)) (input) (2)), "in")) )
| _ -> Some(((((+)) (input) (2)), "in"))) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'f' -> Some(((((+)) (input) (2)), "if"))
| _ -> None) ) else ( None )
| 'f' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))) ) then ( if ( (((<)) ((((+)) (input) (5))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (5)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (7)), "functor")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| _ -> Some(((((+)) (input) (3)), "fun"))) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "for")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )
| _ -> None) ) else ( None )
| 'e' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (8)), "external")) ) else ( None )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )
| _ -> None) ) else ( None )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) (true)))) ) then ( if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'w' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('o'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "downto")) ) else ( Some(((((+)) (input) (2)), "do")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "done")) ) else ( Some(((((+)) (input) (2)), "do")) )
| _ -> Some(((((+)) (input) (2)), "do"))) ) else ( Some(((((+)) (input) (2)), "do")) ) ) else ( None )
| 'c' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (10))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('t'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (10)), "constraint")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "class")) ) else ( None )
| _ -> None) ) else ( None )
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
's' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'r' -> Some(((((+)) (input) (3)), "asr"))
| _ -> Some(((((+)) (input) (2)), "as"))) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )
| _ -> None) ) else ( None )
| '`' -> Some(((((+)) (input) (1)), "`"))
| '_' -> Some(((((+)) (input) (1)), "_"))
| ']' -> Some(((((+)) (input) (1)), "]"))
| '[' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "[|"))
| '>' -> Some(((((+)) (input) (2)), "[>"))
| '<' -> Some(((((+)) (input) (2)), "[<"))
| _ -> Some(((((+)) (input) (1)), "["))) ) else ( Some(((((+)) (input) (1)), "[")) )
| '?' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) (true)))) ) then ( Some(((((+)) (input) (2)), "??")) ) else ( Some(((((+)) (input) (1)), "?")) )
| '>' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'}' -> Some(((((+)) (input) (2)), ">}"))
| ']' -> Some(((((+)) (input) (2)), ">]"))
| _ -> Some(((((+)) (input) (1)), ">"))) ) else ( Some(((((+)) (input) (1)), ">")) )
| '=' -> Some(((((+)) (input) (1)), "="))
| '<' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( Some(((((+)) (input) (1)), "<")) )
| ';' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (';'))) (true)))) ) then ( Some(((((+)) (input) (2)), ";;")) ) else ( Some(((((+)) (input) (1)), ";")) )
| ':' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), ":>"))
| '=' -> Some(((((+)) (input) (2)), ":="))
| ':' -> Some(((((+)) (input) (2)), "::"))
| _ -> Some(((((+)) (input) (1)), ":"))) ) else ( Some(((((+)) (input) (1)), ":")) )
| '.' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))) ) then ( Some(((((+)) (input) (2)), "..")) ) else ( Some(((((+)) (input) (1)), ".")) )
| '-' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), "->"))
| '.' -> Some(((((+)) (input) (2)), "-."))
| _ -> Some(((((+)) (input) (1)), "-"))) ) else ( Some(((((+)) (input) (1)), "-")) )
| ',' -> Some(((((+)) (input) (1)), ","))
| '+' -> Some(((((+)) (input) (1)), "+"))
| '*' -> Some(((((+)) (input) (1)), "*"))
| ')' -> Some(((((+)) (input) (1)), ")"))
| '(' -> Some(((((+)) (input) (1)), "("))
| '\'' -> Some(((((+)) (input) (1)), "'"))
| '&' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( Some(((((+)) (input) (1)), "&")) )
| '#' -> Some(((((+)) (input) (1)), "#"))
| _ -> None) ) else ( None ) in
(Hashtbl.add (memo_Ocaml_keywords_KEYWORDS) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent_cont_noerr = 
#50 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((=)) (c) ('_'))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('\'')))))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Ocaml_parser_mlIdent_aux__noerr = 
#51 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux_) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_306, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_308 -> (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_308)))) (input_306)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_307, __2 ) ) -> Some((input_307, (_get_sub (input) ((((-)) (input_307) (input)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_305, __1 ) ) -> Some((input_305, 
#51 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux_) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent__noerr = 
#56 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_313, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_313)) with
None -> let input_314 = input_313 in
let __2 = () in
Some((input_314, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_311 = input in
let __1 = () in
(match (try_Ocaml_parser_mlIdent_aux__noerr (_filename) (_text) (input_311)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_312, __2 ) ) -> Some((input_312, 
#56 "ocaml_parser.trx"
( __2  ))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent_aux_noerr = 
#52 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_aux__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_309, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_309)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_310, __2 ) ) -> Some((input_310, 
#52 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent_noerr = 
#53 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_323, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_323)) with
None -> let input_324 = input_323 in
let __2 = () in
Some((input_324, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_321 = input in
let __1 = () in
(match (try_Ocaml_parser_mlIdent_aux_noerr (_filename) (_text) (input_321)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_322, __2 ) ) -> Some((input_322, 
#53 "ocaml_parser.trx"
( __2  ))))
| Some ( ( _, _ ) ) -> None) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_315, __1 ) ) -> (match (match if ( (((<)) (input_315) (_len)) ) then ( let c = ((_get_char) (input_315)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_315)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_318, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_320 -> if ( (((<)) (input_320) (_len)) ) then ( let c = ((_get_char) (input_320)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_320)), c)) ) else ( None ) ) else ( None ))) (input_318)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_319, __2 ) ) -> Some((input_319, (_get_sub (input_315) ((((-)) (input_319) (input_315)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_316, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_316)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_317, __3 ) ) -> Some((input_317, 
#55 "ocaml_parser.trx"
( sprintf "(%s)" __2  ))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent) (input) (res)) ; res)
)
let rec try_Default_laccol_noerr = 
#65 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_laccol) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('{')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_896, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_896)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_897, __2 ) ) -> Some((input_897, ( () ))))) in
(Hashtbl.add (memo_Default_laccol) (input) (res)) ; res)
)
let rec try_Default_lbracket_noerr = 
#71 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lbracket) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('[')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_894, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_894)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_895, __2 ) ) -> Some((input_895, ( () ))))) in
(Hashtbl.add (memo_Default_lbracket) (input) (res)) ; res)
)
let rec try_Default_raccol_noerr = 
#66 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_raccol) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('}')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_851, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_851)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_852, __2 ) ) -> Some((input_852, ( () ))))) in
(Hashtbl.add (memo_Default_raccol) (input) (res)) ; res)
)
let rec try_Default_rbracket_noerr = 
#72 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rbracket) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (']')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_849, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_849)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_850, __2 ) ) -> Some((input_850, ( () ))))) in
(Hashtbl.add (memo_Default_rbracket) (input) (res)) ; res)
)
let rec try_Default_underscore_noerr = 
#82 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_underscore) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_762, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_762)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_763, __2 ) ) -> Some((input_763, ( () ))))) in
(Hashtbl.add (memo_Default_underscore) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_AS_noerr = 
#51 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "as")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_756, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_756)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_757, __2 ) ) -> Some((input_757, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_AS) (input) (res)) ; res)
)
let rec try_Default_stringcharspecial_noerr = 
#33 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringcharspecial) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('n')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_797, __1 ) ) -> Some((input_797, 
#34 "default.trx"
( '\n'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('r')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_796, __1 ) ) -> Some((input_796, 
#34 "default.trx"
( '\r'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('t')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_795, __1 ) ) -> Some((input_795, 
#34 "default.trx"
( '\t'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_794, __1 ) ) -> Some((input_794, 
#35 "default.trx"
( '\''  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_793, __1 ) ) -> Some((input_793, 
#35 "default.trx"
( '\"'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_792, __1 ) ) -> Some((input_792, 
#35 "default.trx"
( '\\'  )))) with
None -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_791 -> if ( (((<)) (input_791) (_len)) ) then ( let c = ((_get_char) (input_791)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_791)), c)) ) else ( None ) ) else ( None ))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_790, __1 ) ) -> Some((input_790, 
#36 "default.trx"
( char_of_int (Tgrammar.int_of_chars __1)  ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringcharspecial) (input) (res)) ; res)
)
let rec try_Default_singlequotechar__noerr = 
#40 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_singlequotechar_) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_834, __1 ) ) -> (match (try_Default_stringcharspecial_noerr (_filename) (_text) (input_834)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_835, __2 ) ) -> Some((input_835, 
#41 "default.trx"
( __2  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('\'')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> let input_832 = input in
let __1 = () in
if ( (((<)) (input_832) (_len)) ) then ( let c = ((_get_char) (input_832)) in
Some((((succ) (input_832)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_singlequotechar_) (input) (res)) ; res)
)
let rec try_Default_charsinglequote_noerr = 
#46 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_charsinglequote) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_928, __1 ) ) -> (match (try_Default_singlequotechar__noerr (_filename) (_text) (input_928)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_929, __2 ) ) -> (match if ( (((<)) (input_929) (_len)) ) then ( let c = ((_get_char) (input_929)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_929)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_930, __3 ) ) -> Some((input_930, 
#46 "default.trx"
( __2  )))))) in
(Hashtbl.add (memo_Default_charsinglequote) (input) (res)) ; res)
)
let rec try_Default_strfloat_noerr = 
#97 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strfloat) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> Some((input, None))
| Some ( ( input_816, r ) ) -> Some((input_816, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_804, __1 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_815 -> if ( (((<)) (input_815) (_len)) ) then ( let c = ((_get_char) (input_815)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_815)), c)) ) else ( None ) ) else ( None ))) (input_804)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_811, __1 ) ) -> (match if ( (((<)) (input_811) (_len)) ) then ( let c = ((_get_char) (input_811)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_811)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_812, __2 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_814 -> if ( (((<)) (input_814) (_len)) ) then ( let c = ((_get_char) (input_814)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_814)), c)) ) else ( None ) ) else ( None ))) (input_812)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_813, __3 ) ) -> Some((input_813, ()))))) with
None -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_810 -> if ( (((<)) (input_810) (_len)) ) then ( let c = ((_get_char) (input_810)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_810)), c)) ) else ( None ) ) else ( None ))) (input_804)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_806, __1 ) ) -> (match if ( (((<)) (input_806) (_len)) ) then ( let c = ((_get_char) (input_806)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_806)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_807, __2 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_809 -> if ( (((<)) (input_809) (_len)) ) then ( let c = ((_get_char) (input_809)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_809)), c)) ) else ( None ) ) else ( None ))) (input_807)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_808, __3 ) ) -> Some((input_808, ())))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_805, __2 ) ) -> Some((input_805, (_get_sub (input) ((((-)) (input_805) (input)))))))) in
(Hashtbl.add (memo_Default_strfloat) (input) (res)) ; res)
)
let rec try_Default_float_noerr = 
#98 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_float) (input))
) with
Not_found -> let res = (match (try_Default_strfloat_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_916, __1 ) ) -> Some((input_916, 
#98 "default.trx"
( float_of_string __1  )))) in
(Hashtbl.add (memo_Default_float) (input) (res)) ; res)
)
let rec try_Default_strint_noerr = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strint) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> Some((input, None))
| Some ( ( input_774, r ) ) -> Some((input_774, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_771, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_773 -> if ( (((<)) (input_773) (_len)) ) then ( let c = ((_get_char) (input_773)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_773)), c)) ) else ( None ) ) else ( None ))) (input_771)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_772, __2 ) ) -> Some((input_772, (_get_sub (input) ((((-)) (input_772) (input)))))))) in
(Hashtbl.add (memo_Default_strint) (input) (res)) ; res)
)
let rec try_Default_int_noerr = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_int) (input))
) with
Not_found -> let res = (match (try_Default_strint_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_911, __1 ) ) -> Some((input_911, 
#95 "default.trx"
( int_of_string __1  )))) in
(Hashtbl.add (memo_Default_int) (input) (res)) ; res)
)
let rec try_Default_stringchar_noerr = 
#37 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringchar) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_800, __1 ) ) -> (match (try_Default_stringcharspecial_noerr (_filename) (_text) (input_800)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_801, __2 ) ) -> Some((input_801, 
#38 "default.trx"
( __2  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('"')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> let input_798 = input in
let __1 = () in
if ( (((<)) (input_798) (_len)) ) then ( let c = ((_get_char) (input_798)) in
Some((((succ) (input_798)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringchar) (input) (res)) ; res)
)
let rec try_Default_stringnosp_noerr = 
#28 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringnosp) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_786, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_789 -> (try_Default_stringchar_noerr (_filename) (_text) (input_789)))) (input_786)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_787, __2 ) ) -> (match if ( (((<)) (input_787) (_len)) ) then ( let c = ((_get_char) (input_787)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_787)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_788, __3 ) ) -> Some((input_788, 
#28 "default.trx"
( Tgrammar.string_of_chars __2  )))))) in
(Hashtbl.add (memo_Default_stringnosp) (input) (res)) ; res)
)
let rec try_Default_string_noerr = 
#27 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_string) (input))
) with
Not_found -> let res = (match (try_Default_stringnosp_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_802, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_802)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_803, __2 ) ) -> Some((input_803, 
#27 "default.trx"
( __1  ))))) in
(Hashtbl.add (memo_Default_string) (input) (res)) ; res)
)
let rec try_Ocaml_parser_unit_noerr = 
#38 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_unit) (input))
) with
Not_found -> let res = (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_147, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_147)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_148, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_148)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_149, __3 ) ) -> Some((input_149, ( () )))))) in
(Hashtbl.add (memo_Ocaml_parser_unit) (input) (res)) ; res)
)
let rec try_Ocaml_parser_const_noerr = 
#39 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_const) (input))
) with
Not_found -> let res = (match (match (try_Default_float_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_352, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_352)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_353, __2 ) ) -> Some((input_353, 
#40 "ocaml_parser.trx"
( Float __1  ))))) with
None -> (match (match (try_Default_int_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_350, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_350)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_351, __2 ) ) -> Some((input_351, 
#41 "ocaml_parser.trx"
( Int __1  ))))) with
None -> (match (match (try_Default_string_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_348, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_348)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_349, __2 ) ) -> Some((input_349, 
#42 "ocaml_parser.trx"
( String __1  ))))) with
None -> (match (match (try_Default_charsinglequote_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_346, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_346)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_347, __2 ) ) -> Some((input_347, 
#44 "ocaml_parser.trx"
( Char (__1)  ))))) with
None -> (match (match (try_Ocaml_parser_unit_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_345, __1 ) ) -> Some((input_345, 
#45 "ocaml_parser.trx"
( Unit  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_343, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_343)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_344, __2 ) ) -> Some((input_344, 
#46 "ocaml_parser.trx"
( Bool false  ))))) with
None -> (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_341, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_341)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_342, __2 ) ) -> Some((input_342, 
#47 "ocaml_parser.trx"
( Bool true  )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_const) (input) (res)) ; res)
)
let rec try_Ocaml_parser_capMlIdent__noerr = 
#116 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent_) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('`'))) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_355, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_357 -> (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_357)))) (input_355)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_356, __2 ) ) -> Some((input_356, (_get_sub (input) ((((-)) (input_356) (input)))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent_) (input) (res)) ; res)
)
let rec try_Ocaml_parser_constructorName_noerr = 
#121 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_constructorName) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (false) ((fun input_338 -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_338)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_339, __1 ) ) -> (match if ( (((<)) (input_339) (_len)) ) then ( let c = ((_get_char) (input_339)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_339)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_340, __2 ) ) -> Some((input_340, 
#121 "ocaml_parser.trx"
( __1 ))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_334, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_334)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_335, __2 ) ) -> (match if ( (((<)) (input_335) (_len)) ) then ( let c = ((_get_char) (input_335)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_335)), c)) ) else ( None ) ) else ( None ) with
None -> let input_336 = input_335 in
let __3 = () in
(match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_336)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_337, __4 ) ) -> Some((input_337, 
#121 "ocaml_parser.trx"
( __1 @ [__2]  ))))
| Some ( ( _, _ ) ) -> None))) in
(Hashtbl.add (memo_Ocaml_parser_constructorName) (input) (res)) ; res)
)
let rec try_Ocaml_types_spacing_noerr = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_124 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_124)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_126, __1 ) ) -> Some((input_126, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_124))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_123, __1 ) ) -> Some((input_123, ( () )))) in
(Hashtbl.add (memo_Ocaml_types_spacing) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_OF_noerr = 
#50 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "of")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_716, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_716)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_717, __2 ) ) -> Some((input_717, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_OF) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent_cont_noerr = 
#31 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Ocaml_types_typeconstructor_noerr = 
#34 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconstructor) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_88, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_90 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_90)))) (input_88)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_89, __2 ) ) -> Some((input_89, (_get_sub (input) ((((-)) (input_89) (input)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_86, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_86)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_87, __2 ) ) -> Some((input_87, 
#34 "ocaml_types.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_types_typeconstructor) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MUTABLE_noerr = 
#64 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MUTABLE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_718, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_718)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_719, __2 ) ) -> Some((input_719, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MUTABLE) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent_aux_noerr = 
#32 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_aux) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_109, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_111 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_111)))) (input_109)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_110, __2 ) ) -> Some((input_110, (_get_sub (input) ((((-)) (input_110) (input)))))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_106, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_108 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_108)))) (input_106)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_107, __2 ) ) -> Some((input_107, (_get_sub (input) ((((-)) (input_107) (input))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_aux) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent_noerr = 
#33 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_115, __1 ) ) -> (match (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_115)) with
None -> let input_116 = input_115 in
let __2 = () in
Some((input_116, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_112 = input in
let __1 = () in
(match (try_Ocaml_types_typeIdent_aux_noerr (_filename) (_text) (input_112)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_113, __2 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_113)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_114, __3 ) ) -> Some((input_114, 
#33 "ocaml_types.trx"
( __2  )))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_types_typeIdent) (input) (res)) ; res)
)
let rec try_Ocaml_types_BoolT_noerr = 
#29 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "bool")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_146, __1 ) ) -> Some((input_146, 
#29 "ocaml_types.trx"
( TypeBool  )))))
let rec try_Ocaml_types_CharT_noerr = 
#28 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "char")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_145, __1 ) ) -> Some((input_145, 
#28 "ocaml_types.trx"
( TypeChar  )))))
let rec try_Ocaml_types_FloatT_noerr = 
#25 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "float")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_144, __1 ) ) -> Some((input_144, 
#25 "ocaml_types.trx"
( TypeFloat  )))))
let rec try_Ocaml_types_Int64T_noerr = 
#24 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('6'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('4'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "int64")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_143, __1 ) ) -> Some((input_143, 
#24 "ocaml_types.trx"
( TypeInt64  )))))
let rec try_Ocaml_types_IntT_noerr = 
#23 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "int")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_142, __1 ) ) -> Some((input_142, 
#23 "ocaml_types.trx"
( TypeInt  )))))
let rec try_Ocaml_types_StringT_noerr = 
#26 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('g'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "string")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_141, __1 ) ) -> Some((input_141, 
#26 "ocaml_types.trx"
( TypeString  )))))
let rec try_Ocaml_types_UnitT_noerr = 
#27 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "unit")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_140, __1 ) ) -> Some((input_140, 
#27 "ocaml_types.trx"
( TypeUnit  )))))
let rec try_Ocaml_types_typeconst_noerr = 
#22 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconst) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_IntT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_Int64T_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_FloatT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_StringT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_UnitT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_CharT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_types_BoolT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_91, __1 ) ) -> Some((input_91, 
#22 "ocaml_types.trx"
( TypeConst __1  )))) in
(Hashtbl.add (memo_Ocaml_types_typeconst) (input) (res)) ; res)
)
let rec try_Ocaml_types_typename_noerr = 
#36 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typename) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeconstructor_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_37, __1 ) ) -> (match if ( (((<)) (input_37) (_len)) ) then ( let c = ((_get_char) (input_37)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_37)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_38, __2 ) ) -> (match (try_Ocaml_types_typename_noerr (_filename) (_text) (input_38)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_39, __3 ) ) -> Some((input_39, 
#36 "ocaml_types.trx"
( __1 :: __3  )))))) with
None -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_36, __1 ) ) -> Some((input_36, 
#37 "ocaml_types.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typename) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevar_noerr = 
#35 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevar) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_15, __1 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_15)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_16, __2 ) ) -> Some((input_16, 
#35 "ocaml_types.trx"
( TypeVar ("'" ^ __2)  ))))) in
(Hashtbl.add (memo_Ocaml_types_typevar) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevarorname_noerr = 
#46 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevarorname) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input)) with
None -> (match (match (match (try_Ocaml_types_typeconst_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_12, __1 ) ) -> (match (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_12)) with
None -> let input_13 = input_12 in
let __2 = () in
Some((input_13, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_10 = input in
let __1 = () in
(match (try_Ocaml_types_typename_noerr (_filename) (_text) (input_10)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_11, __2 ) ) -> Some((input_11, 
#46 "ocaml_types.trx"
( TypeName ([], __2)  ))))
| Some ( ( _, _ ) ) -> None) with
None -> (match (try_Ocaml_types_typeconst_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_8, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_8)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_9, __2 ) ) -> Some((input_9, 
#46 "ocaml_types.trx"
( __1  )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevarorname) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedef_noerr = 
#89 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typedef_no_arrow_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_69, __1 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_69)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_70, __2 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_70)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_71, __3 ) ) -> Some((input_71, 
#90 "ocaml_types.trx"
( TypeArrow ( __1, __3)  )))))) with
None -> (match (try_Ocaml_types_typedef_no_arrow_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_68, __1 ) ) -> Some((input_68, 
#91 "ocaml_types.trx"
( __1  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_base_noerr = 
#65 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_base) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeSum_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_typerecord_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_typevarorname_noerr (_filename) (_text) (input)) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_58, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_58)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_59, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_59)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_60, __3 ) ) -> Some((input_60, 
#67 "ocaml_types.trx"
( __2  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_base) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_aux_noerr = 
#96 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_onetyperecord_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_17, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_21 -> (match (try_Default_semi_noerr (_filename) (_text) (input_21)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_22, __1 ) ) -> (match (try_Ocaml_types_onetyperecord_noerr (_filename) (_text) (input_22)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_23, __2 ) ) -> Some((input_23, 
#96 "ocaml_types.trx"
( __2  ))))))) (input_17)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_18, __2 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_18)) with
None -> Some((input_18, None))
| Some ( ( input_20, r ) ) -> Some((input_20, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_19, __3 ) ) -> Some((input_19, 
#96 "ocaml_types.trx"
( __1 ::__2  )))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_aux) (input) (res)) ; res)
)
and try_Ocaml_types_typeparam_noerr = 
#69 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeparam) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_29, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_29)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_30, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_33 -> (match (try_Default_comma_noerr (_filename) (_text) (input_33)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_34, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_34)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_35, __2 ) ) -> Some((input_35, 
#70 "ocaml_types.trx"
( __2 ))))))) (input_30)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_31, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_31)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_32, __4 ) ) -> Some((input_32, 
#70 "ocaml_types.trx"
( __2 :: __3  ))))))) with
None -> (match (try_Ocaml_types_typedef_base_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_28, __1 ) ) -> Some((input_28, 
#71 "ocaml_types.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeparam) (input) (res)) ; res)
)
and try_Ocaml_types_typeSum_noerr = 
#98 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeSum) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeconstructor_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_99, __1 ) ) -> (match if ( (((<)) (input_99) (_len)) ) then ( let c = ((_get_char) (input_99)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_99)), c)) ) else ( None ) ) else ( None ) with
None -> let input_100 = input_99 in
let __2 = () in
(match (match (match (try_Ocaml_keywords_OF_noerr (_filename) (_text) (input_100)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_102, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_102)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_103, __2 ) ) -> Some((input_103, 
#98 "ocaml_types.trx"
( __2 ))))) with
None -> Some((input_100, None))
| Some ( ( input_104, r ) ) -> Some((input_104, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_101, __3 ) ) -> Some((input_101, 
#98 "ocaml_types.trx"
( TypeConstructor [__1, __3]  ))))
| Some ( ( _, _ ) ) -> None)) in
(Hashtbl.add (memo_Ocaml_types_typeSum) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_no_arrow_noerr = 
#82 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_no_arrow) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_52, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_54 -> (match if ( (((<)) (input_54) (_len)) ) then ( let c = ((_get_char) (input_54)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input_54)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_55, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_55)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_56, __2 ) ) -> (match (try_Ocaml_types_typedef_aux_noerr (_filename) (_text) (input_56)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_57, __3 ) ) -> Some((input_57, 
#82 "ocaml_types.trx"
( __3 )))))))) (input_52)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_53, __2 ) ) -> Some((input_53, 
#82 "ocaml_types.trx"
( match (__1::__2) with
    | [] -> error "@Ocaml_types.typedef_no_arrow : empty type tuple"
    | [td] -> td
    | tdl -> TypeTuple tdl
 ))))) in
(Hashtbl.add (memo_Ocaml_types_typedef_no_arrow) (input) (res)) ; res)
)
and try_Ocaml_types_onetyperecord_noerr = 
#95 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_onetyperecord) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MUTABLE_noerr (_filename) (_text) (input)) with
None -> Some((input, None))
| Some ( ( input_131, r ) ) -> Some((input_131, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_127, __1 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_127)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_128, __2 ) ) -> (match (try_Default_colon_noerr (_filename) (_text) (input_128)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_129, __3 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_129)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_130, __4 ) ) -> Some((input_130, 
#95 "ocaml_types.trx"
( (match __1 with None -> false | _ -> true), __2, __4  ))))))) in
(Hashtbl.add (memo_Ocaml_types_onetyperecord) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_aux_noerr = 
#73 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_aux) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeparam_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_65, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_67 -> (try_Ocaml_types_typename_noerr (_filename) (_text) (input_67)))) (input_65)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_66, __2 ) ) -> Some((input_66, 
#74 "ocaml_types.trx"
( match __2 with
| hd :: tl -> 
  List.fold_left (fun acc x -> TypeName ([acc], x)) (TypeName (__1, hd)) tl 
| _ -> assert false
 ))))) with
None -> (try_Ocaml_types_typedef_base_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_aux) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_noerr = 
#102 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord) (input))
) with
Not_found -> let res = (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_24, __1 ) ) -> (match (match (try_Ocaml_types_typerecord_aux_noerr (_filename) (_text) (input_24)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_27, __1 ) ) -> Some((input_27, 
#102 "ocaml_types.trx"
( TypeRecord __1  )))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_25, __2 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_25)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_26, __3 ) ) -> Some((input_26, 
#101 "ocaml_types.trx"
( __2  )))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord) (input) (res)) ; res)
)
let rec try_Ocaml_parser_type_noerr = 
#123 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_type) (input))
) with
Not_found -> let res = (try_Ocaml_types_typedef_noerr (_filename) (_text) (input)) in
(Hashtbl.add (memo_Ocaml_parser_type) (input) (res)) ; res)
)
let rec try_Ocaml_parser_pattern_aux_noerr = 
#178 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_l_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_213, __1 ) ) -> Some((input_213, 
#179 "ocaml_parser.trx"
( match __1 with
     | [t] -> t
     | _ -> PatTuple __1
   )))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_cons_noerr = 
#164 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_cons) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_155, __1 ) ) -> (match (match (match (try_Ocaml_keywords_CONS_noerr (_filename) (_text) (input_155)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_157, __1 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_157)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_158, __2 ) ) -> Some((input_158, 
#164 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_155, None))
| Some ( ( input_159, r ) ) -> Some((input_159, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_156, __2 ) ) -> Some((input_156, 
#165 "ocaml_parser.trx"
( match __2 with
     | None -> __1
     | Some x -> PatList (__1, x)
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_cons) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_aux_noerr = 
#127 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_aux) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_212, __1 ) ) -> Some((input_212, 
#129 "ocaml_parser.trx"
( PatVar (Ident.source __1)  )))) with
None -> (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_205, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_205)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_206, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_206)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_209, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_209)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_210, __2 ) ) -> Some((input_210, ())))) with
None -> Some((input_206, None))
| Some ( ( input_211, r ) ) -> Some((input_211, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_207, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_207)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_208, __4 ) ) -> Some((input_208, 
#131 "ocaml_parser.trx"
( __2  ))))))) with
None -> (match (match (try_Default_underscore_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_204, __1 ) ) -> Some((input_204, 
#133 "ocaml_parser.trx"
( PatAny  )))) with
None -> (match (match (try_Ocaml_parser_const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_203, __1 ) ) -> Some((input_203, 
#135 "ocaml_parser.trx"
( PatConst __1  )))) with
None -> (match (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_190, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_190)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_191, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_191)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_192, __3 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_192)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_193, __4 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_198 -> (match (try_Default_semi_noerr (_filename) (_text) (input_198)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_199, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_199)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_200, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_200)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_201, __3 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_201)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_202, __4 ) ) -> Some((input_202, 
#137 "ocaml_parser.trx"
( __2, __4 ))))))))) (input_193)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_194, __5 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_194)) with
None -> Some((input_194, None))
| Some ( ( input_197, r ) ) -> Some((input_197, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_195, __6 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_195)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_196, __7 ) ) -> Some((input_196, 
#138 "ocaml_parser.trx"
( PatRecord ((__2, __4)::__5)
     )))))))))) with
None -> (match (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_181, __1 ) ) -> (match (match (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_181)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_184, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_186 -> (match (try_Default_semi_noerr (_filename) (_text) (input_186)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_187, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_187)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_188, __2 ) ) -> Some((input_188, 
#142 "ocaml_parser.trx"
( __2 ))))))) (input_184)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_185, __2 ) ) -> Some((input_185, 
#142 "ocaml_parser.trx"
( __1, __2 ))))) with
None -> Some((input_181, None))
| Some ( ( input_189, r ) ) -> Some((input_189, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_182, __2 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_182)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_183, __3 ) ) -> Some((input_183, 
#143 "ocaml_parser.trx"
( match __2 with
       | None -> PatEmptyList
       | Some (a, l) ->
           PatList (a, List.fold_right (fun e accu -> PatList (e, accu)) l PatEmptyList)
     )))))) with
None -> (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_173, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_173)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_174, __2 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_174)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_175, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_178 -> (match (try_Default_comma_noerr (_filename) (_text) (input_178)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_179, __1 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_179)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_180, __2 ) ) -> Some((input_180, 
#150 "ocaml_parser.trx"
( __2 ))))))) (input_175)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_176, __4 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_176)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_177, __5 ) ) -> Some((input_177, 
#151 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, __3::__4)
     )))))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_170, __1 ) ) -> (match (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_170)) with
None -> Some((input_170, None))
| Some ( ( input_172, r ) ) -> Some((input_172, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_171, __2 ) ) -> Some((input_171, 
#156 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, match __2 with Some x -> [x] | None -> [])
     )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_165, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_167 -> (match (try_Ocaml_keywords_AS_noerr (_filename) (_text) (input_167)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_168, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_168)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_169, __2 ) ) -> Some((input_169, 
#159 "ocaml_parser.trx"
( __2 ))))))) (input_165)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_166, __2 ) ) -> Some((input_166, 
#160 "ocaml_parser.trx"
( List.fold_left (fun accu e -> PatAs (accu, Ident.source e)) __1 __2
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_l_noerr = 
#171 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_l) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_160, __1 ) ) -> (match (match (match (try_Default_comma_noerr (_filename) (_text) (input_160)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_162, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_l_noerr (_filename) (_text) (input_162)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_163, __2 ) ) -> Some((input_163, 
#171 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_160, None))
| Some ( ( input_164, r ) ) -> Some((input_164, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_161, __2 ) ) -> Some((input_161, 
#172 "ocaml_parser.trx"
( match __2 with
     | None -> [__1]
     | Some s -> __1::s
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_l) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_ASSERT_noerr = 
#65 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ASSERT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_754, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_754)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_755, __2 ) ) -> Some((input_755, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_ASSERT) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_ELSE_noerr = 
#73 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ELSE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_742, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_742)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_743, __2 ) ) -> Some((input_743, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_ELSE) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_IF_noerr = 
#71 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "if")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_728, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_728)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_729, __2 ) ) -> Some((input_729, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_IF) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_THEN_noerr = 
#72 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_THEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_700, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_700)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_701, __2 ) ) -> Some((input_701, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_THEN) (input) (res)) ; res)
)
let rec try_Ocaml_parser_emptylist_noerr = 
#37 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_emptylist) (input))
) with
Not_found -> let res = (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_328, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_328)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_329, __2 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_329)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_330, __3 ) ) -> Some((input_330, 
#37 "ocaml_parser.trx"
( EmptyList  )))))) in
(Hashtbl.add (memo_Ocaml_parser_emptylist) (input) (res)) ; res)
)
let rec try_Ocaml_parser_EmptyList_noerr = 
#226 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_EmptyList) (input))
) with
Not_found -> let res = (try_Ocaml_parser_emptylist_noerr (_filename) (_text) (input)) in
(Hashtbl.add (memo_Ocaml_parser_EmptyList) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_EXCEPTION_noerr = 
#61 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_EXCEPTION) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_738, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_738)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_739, __2 ) ) -> Some((input_739, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_EXCEPTION) (input) (res)) ; res)
)
let rec try_Ocaml_parser_capMlIdent_noerr = 
#117 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_358, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_358)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_359, __2 ) ) -> Some((input_359, 
#117 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Exception_noerr = 
#280 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Exception) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_EXCEPTION_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_620, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input_620)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_621, __2 ) ) -> (match (match (match (try_Ocaml_keywords_OF_noerr (_filename) (_text) (input_621)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_623, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_623)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_624, __2 ) ) -> Some((input_624, ())))) with
None -> Some((input_621, None))
| Some ( ( input_625, r ) ) -> Some((input_625, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_622, __3 ) ) -> Some((input_622, 
#280 "ocaml_parser.trx"
( Exception (__2, None) (* FIXME *) )))))) in
(Hashtbl.add (memo_Ocaml_parser_Exception) (input) (res)) ; res)
)
let rec try_Default_leftarrow_noerr = 
#85 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_leftarrow) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_892, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_892)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_893, __2 ) ) -> Some((input_893, ( () ))))) in
(Hashtbl.add (memo_Default_leftarrow) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Const_noerr = 
#218 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Const) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_650, __1 ) ) -> Some((input_650, 
#218 "ocaml_parser.trx"
( Const __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Const) (input) (res)) ; res)
)
let rec try_Default_dot_noerr = 
#78 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_dot) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_922, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_922)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_923, __2 ) ) -> Some((input_923, ( () ))))) in
(Hashtbl.add (memo_Default_dot) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Dot_noerr = 
#315 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Dot) (input))
) with
Not_found -> let res = (match (try_Default_dot_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_627, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_636 -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_636)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_637, __1 ) ) -> (match if ( (((<)) (input_637) (_len)) ) then ( let c = ((_get_char) (input_637)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_637)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_638, __2 ) ) -> Some((input_638, 
#315 "ocaml_parser.trx"
( __1 ))))))) (input_627)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_635, __1 ) ) -> Some((input_635, 
#315 "ocaml_parser.trx"
( __1  )))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_628, __2 ) ) -> (match (match (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_628)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_634, __1 ) ) -> Some((input_634, 
#315 "ocaml_parser.trx"
( `MlIdent __1 )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input_628)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_630, __1 ) ) -> (match (try_Default_int_noerr (_filename) (_text) (input_630)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_631, __2 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_631)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_632, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_632)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_633, __4 ) ) -> Some((input_633, 
#315 "ocaml_parser.trx"
( `Int __2 )))))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_629, __3 ) ) -> Some((input_629, 
#315 "ocaml_parser.trx"
( match __3 with `MlIdent s ->
  let tmp = String.concat_map "." (fun s -> s) __2 in
  let tmp = if tmp = "" then "" else tmp ^ "." in
  `MlIdent (tmp ^ s) | `Int i -> `Int i  )))))) in
(Hashtbl.add (memo_Ocaml_parser_Dot) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_BEGIN_noerr = 
#58 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_BEGIN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_752, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_752)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_753, __2 ) ) -> Some((input_753, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_BEGIN) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_END_noerr = 
#56 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_END) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_740, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_740)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_741, __2 ) ) -> Some((input_741, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_END) (input) (res)) ; res)
)
let rec try_Ocaml_parser_RNameOpt_noerr = 
#257 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_RNameOpt) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_409, __1 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_409)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_410, __2 ) ) -> Some((input_410, 
#257 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_RNameOpt) (input) (res)) ; res)
)
let rec try_Ocaml_parser_moduleName__noerr = 
#119 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName_) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_302, __1 ) ) -> Some((input_302, 
#119 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName_) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_AND_noerr = 
#49 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AND) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_760, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_760)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_761, __2 ) ) -> Some((input_761, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_AND) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_IN_noerr = 
#44 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "in")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_726, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_726)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_727, __2 ) ) -> Some((input_727, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_IN) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_LET_noerr = 
#42 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_LET) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_724, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_724)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_725, __2 ) ) -> Some((input_725, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_LET) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_REC_noerr = 
#45 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REC) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_708, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_708)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_709, __2 ) ) -> Some((input_709, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_REC) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_REF_noerr = 
#60 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('f'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "ref")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_706, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_706)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_707, __2 ) ) -> Some((input_707, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_REF) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MODULE_noerr = 
#54 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MODULE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_720, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_720)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_721, __2 ) ) -> Some((input_721, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MODULE) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_STRUCT_noerr = 
#55 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_STRUCT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_702, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_702)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_703, __2 ) ) -> Some((input_703, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_STRUCT) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_TYPE_noerr = 
#48 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TYPE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_694, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_694)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_695, __2 ) ) -> Some((input_695, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_TYPE) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedeflist_noerr = 
#57 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeflist) (input))
) with
Not_found -> let res = (match (match (try_Default_bar_noerr (_filename) (_text) (input)) with
None -> Some((input, None))
| Some ( ( input_51, r ) ) -> Some((input_51, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_45, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_45)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_46, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_48 -> (match (try_Default_bar_noerr (_filename) (_text) (input_48)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_49, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_49)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_50, __2 ) ) -> Some((input_50, 
#57 "ocaml_types.trx"
( __2  ))))))) (input_46)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_47, __3 ) ) -> Some((input_47, 
#57 "ocaml_types.trx"
( match __2, __3 with
| _, [] -> __2
| TypeConstructor l1, l2 -> 
	TypeConstructor ( l1 @ List.flatten (List.map (function | TypeConstructor l -> l | _ -> error "@Ocaml_types.typedeflist : must be a constructor") l2))
| _x, _xl -> error "@Ocaml_types.typedeflist : impossible"
 )))))) in
(Hashtbl.add (memo_Ocaml_types_typedeflist) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevars_noerr = 
#44 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevars) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_7, __1 ) ) -> Some((input_7, 
#44 "ocaml_types.trx"
( [__1]  )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_0, __1 ) ) -> (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input_0)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_1, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_4 -> (match (try_Default_comma_noerr (_filename) (_text) (input_4)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_5, __1 ) ) -> (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input_5)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_6, __2 ) ) -> Some((input_6, 
#45 "ocaml_types.trx"
( __2  ))))))) (input_1)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_2, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_2)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_3, __4 ) ) -> Some((input_3, 
#45 "ocaml_types.trx"
( __2 :: __3  )))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevars) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedeclaration_noerr = 
#49 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeclaration) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TYPE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_72, __1 ) ) -> (match (match (try_Ocaml_types_typevars_noerr (_filename) (_text) (input_72)) with
None -> Some((input_72, None))
| Some ( ( input_85, r ) ) -> Some((input_85, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_73, __2 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_73)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_74, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_74)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_75, __4 ) ) -> (match (try_Ocaml_types_typedeflist_noerr (_filename) (_text) (input_75)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_76, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_78 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_78)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_79, __1 ) ) -> (match (match (try_Ocaml_types_typevars_noerr (_filename) (_text) (input_79)) with
None -> Some((input_79, None))
| Some ( ( input_84, r ) ) -> Some((input_84, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_80, __2 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_80)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_81, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_81)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_82, __4 ) ) -> (match (try_Ocaml_types_typedeflist_noerr (_filename) (_text) (input_82)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_83, __5 ) ) -> Some((input_83, 
#50 "ocaml_types.trx"
( compute_vars __2, __3, __5 )))))))))) (input_76)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_77, __6 ) ) -> Some((input_77, 
#51 "ocaml_types.trx"
( (compute_vars __2, __3, __5) :: __6  ))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeclaration) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Type_noerr = 
#262 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Type) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_361, __1 ) ) -> Some((input_361, 
#262 "ocaml_parser.trx"
( Type __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Type) (input) (res)) ; res)
)
let rec try_Ocaml_parser_moduleName_noerr = 
#118 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_303, __1 ) ) -> Some((input_303, 
#118 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_OPEN_noerr = 
#59 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OPEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_714, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_714)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_715, __2 ) ) -> Some((input_715, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_OPEN) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Open_noerr = 
#194 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Open) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_427, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_427)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_428, __2 ) ) -> Some((input_428, 
#194 "ocaml_parser.trx"
( Open [ Ident.source __2 ] ))))) in
(Hashtbl.add (memo_Ocaml_parser_Open) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_RAISE_noerr = 
#63 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_RAISE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "raise")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_710, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_710)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_711, __2 ) ) -> Some((input_711, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_RAISE) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_GETREF_noerr = 
#78 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_GETREF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ":=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_730, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_730)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_731, __2 ) ) -> Some((input_731, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_GETREF) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_TRY_noerr = 
#62 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TRY) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('y'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "try")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_696, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_696)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_697, __2 ) ) -> Some((input_697, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_TRY) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_WHEN_noerr = 
#80 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WHEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_690, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_690)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_691, __2 ) ) -> Some((input_691, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_WHEN) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FDIV_noerr = 
#411 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FDIV) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "/.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_585, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_585)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_586, __2 ) ) -> Some((input_586, 
#411 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FDIV) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IDIV_noerr = 
#406 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IDIV) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) (true)))) ) then ( Some(((((+)) (input) (1)), "/")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_571, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_571)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_572, __2 ) ) -> Some((input_572, 
#406 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IDIV) (input) (res)) ; res)
)
let rec try_Ocaml_parser_DIV_noerr = 
#401 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_DIV) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FDIV_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IDIV_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_DIV) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FMULT_noerr = 
#410 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMULT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_581, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_581)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_582, __2 ) ) -> Some((input_582, 
#410 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FMULT) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IMULT_noerr = 
#405 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMULT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) (true)))) ) then ( Some(((((+)) (input) (1)), "*")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_567, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_567)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_568, __2 ) ) -> Some((input_568, 
#405 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IMULT) (input) (res)) ; res)
)
let rec try_Ocaml_parser_MULT_noerr = 
#400 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MULT) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FMULT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IMULT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MULT) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel4_noerr = 
#375 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel4) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_MULT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_DIV_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_543, __1 ) ) -> Some((input_543, 
#376 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel4) (input) (res)) ; res)
)
let rec try_Ocaml_parser_SimpleExpr_noerr = 
#325 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SimpleExpr) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_dotable_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_376, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_382 -> (try_Ocaml_parser_Dot_noerr (_filename) (_text) (input_382)))) (input_376)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_377, __2 ) ) -> (match (match (match (try_Default_leftarrow_noerr (_filename) (_text) (input_377)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_379, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_379)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_380, __2 ) ) -> Some((input_380, 
#326 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_377, None))
| Some ( ( input_381, r ) ) -> Some((input_381, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_378, __3 ) ) -> Some((input_378, 
#326 "ocaml_parser.trx"
( let tmp = List.fold_left (fun accu -> function | `MlIdent e -> Dot (accu, e)
        | `Int i -> Dot (accu, sprintf "(%d)" i)) __1 __2 in match __3  with None -> tmp | Some s -> SetMutable (tmp, s)  )))))) with
None -> (match (match (try_Ocaml_parser_Const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_375, __1 ) ) -> Some((input_375, 
#328 "ocaml_parser.trx"
( __1  )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_372, __1 ) ) -> (match (try_Ocaml_parser_op_special_noerr (_filename) (_text) (input_372)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_373, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_373)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_374, __3 ) ) -> Some((input_374, 
#329 "ocaml_parser.trx"
( Var (Pated ([Ident.source __2], true))  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_SimpleExpr) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_aux_noerr = 
#331 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_587, __1 ) ) -> (match (match (match (try_Default_comma_noerr (_filename) (_text) (input_587)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_589, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_aux_noerr (_filename) (_text) (input_589)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_590, __2 ) ) -> Some((input_590, 
#331 "ocaml_parser.trx"
( __2  ))))) with
None -> Some((input_587, None))
| Some ( ( input_591, r ) ) -> Some((input_591, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_588, __2 ) ) -> Some((input_588, 
#331 "ocaml_parser.trx"
( match __2 with None -> [__1] | Some s -> __1::s  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_noerr = 
#332 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_592, __1 ) ) -> Some((input_592, 
#332 "ocaml_parser.trx"
( match __1 with [t] -> t | _ -> Tuple __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq) (input) (res)) ; res)
)
and try_Ocaml_parser_MakeRef_noerr = 
#220 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MakeRef) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_REF_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_489, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_489)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_490, __2 ) ) -> Some((input_490, 
#220 "ocaml_parser.trx"
( MakeRef __2 ))))) in
(Hashtbl.add (memo_Ocaml_parser_MakeRef) (input) (res)) ; res)
)
and try_Ocaml_parser_Try_noerr = 
#287 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Try) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TRY_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_362, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_362)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_363, __2 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_363)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_364, __3 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_364)) with
None -> Some((input_364, None))
| Some ( ( input_371, r ) ) -> Some((input_371, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_365, __4 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_365)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_366, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_368 -> (match (try_Default_bar_noerr (_filename) (_text) (input_368)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_369, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_369)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_370, __2 ) ) -> Some((input_370, 
#288 "ocaml_parser.trx"
( __2  ))))))) (input_366)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_367, __6 ) ) -> Some((input_367, 
#288 "ocaml_parser.trx"
( Try (__2 , __5::__6)  ))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Try) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel3_noerr = 
#337 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel3) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel4_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_434, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel3_noerr (_filename) (_text) (input_434)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_436, __1 ) ) -> (match (try_Ocaml_parser_OpLevel3_noerr (_filename) (_text) (input_436)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_437, __2 ) ) -> Some((input_437, 
#337 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_434, None))
| Some ( ( input_438, r ) ) -> Some((input_438, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_435, __2 ) ) -> Some((input_435, 
#337 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel3) (input) (res)) ; res)
)
and try_Ocaml_parser_App_noerr = 
#339 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_App) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Constructor_noerr (_filename) (_text) (input)) with
None -> (match (match (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_672, __1 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_672) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_672) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_672) (1)), "-")) ) else ( None ) with
None -> let input_673 = input_672 in
let __2 = () in
(match if ( (((&&)) ((((<=)) ((((+)) (input_673) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_673) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_673) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input_673) (2)), "::")) ) else ( None ) with
None -> let input_674 = input_673 in
let __3 = () in
(match if ( (((&&)) ((((<=)) ((((+)) (input_674) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_674) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_674) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input_674) (2)), ":=")) ) else ( None ) with
None -> let input_675 = input_674 in
let __4 = () in
Some((input_675, __1))
| Some ( ( _, _ ) ) -> None)
| Some ( ( _, _ ) ) -> None)
| Some ( ( _, _ ) ) -> None)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_669, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_671 -> (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_671)))) (input_669)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_670, __2 ) ) -> Some((input_670, 
#344 "ocaml_parser.trx"
( match __2 with [] -> __1 | _ -> make_app (__1 :: __2)  ))))) with
None -> (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_App) (input) (res)) ; res)
)
and try_Ocaml_parser_Cons_noerr = 
#223 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cons) (input))
) with
Not_found -> let res = (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_651, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_651)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_652, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_655 -> (match (try_Default_semi_noerr (_filename) (_text) (input_655)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_656, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_656)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_657, __2 ) ) -> Some((input_657, 
#224 "ocaml_parser.trx"
( __2 ))))))) (input_652)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_653, __3 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_653)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_654, __4 ) ) -> Some((input_654, 
#225 "ocaml_parser.trx"
( List.fold_right (fun e accu -> Cons (e, accu)) (__2::__3) EmptyList ))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cons) (input) (res)) ; res)
)
and try_Ocaml_parser_Paren_noerr = 
#320 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Paren) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_414, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_414)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_415, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_415)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_418, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_418)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_419, __2 ) ) -> Some((input_419, ())))) with
None -> Some((input_415, None))
| Some ( ( input_420, r ) ) -> Some((input_420, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_416, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_416)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_417, __4 ) ) -> Some((input_417, 
#320 "ocaml_parser.trx"
( __2  ))))))) with
None -> (match (try_Ocaml_keywords_BEGIN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_411, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_411)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_412, __2 ) ) -> (match (try_Ocaml_keywords_END_noerr (_filename) (_text) (input_412)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_413, __3 ) ) -> Some((input_413, 
#320 "ocaml_parser.trx"
( __2  ))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Paren) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel4_noerr = 
#338 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel4) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_App_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_429, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel4_noerr (_filename) (_text) (input_429)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_431, __1 ) ) -> (match (try_Ocaml_parser_OpLevel4_noerr (_filename) (_text) (input_431)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_432, __2 ) ) -> Some((input_432, 
#338 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_429, None))
| Some ( ( input_433, r ) ) -> Some((input_433, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_430, __2 ) ) -> Some((input_430, 
#338 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel4) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel1_noerr = 
#335 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel1) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel2_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_444, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel1_noerr (_filename) (_text) (input_444)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_446, __1 ) ) -> (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input_446)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_447, __2 ) ) -> Some((input_447, 
#335 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_444, None))
| Some ( ( input_448, r ) ) -> Some((input_448, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_445, __2 ) ) -> Some((input_445, 
#335 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel1) (input) (res)) ; res)
)
and try_Ocaml_parser_Var_noerr = 
#219 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Var) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_paramEffectif_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_360, __1 ) ) -> Some((input_360, 
#219 "ocaml_parser.trx"
( Var __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Var) (input) (res)) ; res)
)
and try_Ocaml_parser_GetRef_noerr = 
#221 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GetRef) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_573, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_573)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_574, __2 ) ) -> Some((input_574, 
#221 "ocaml_parser.trx"
( GetRef __2  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GetRef) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel2_noerr = 
#336 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel2) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel3_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_439, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel2_noerr (_filename) (_text) (input_439)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_441, __1 ) ) -> (match (try_Ocaml_parser_OpLevel2_noerr (_filename) (_text) (input_441)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_442, __2 ) ) -> Some((input_442, 
#336 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_439, None))
| Some ( ( input_443, r ) ) -> Some((input_443, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_440, __2 ) ) -> Some((input_440, 
#336 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel2) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_noerr = 
#185 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_214, __1 ) ) -> (match (match (match (try_Ocaml_keywords_WHEN_noerr (_filename) (_text) (input_214)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_216, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_216)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_217, __2 ) ) -> Some((input_217, 
#185 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_214, None))
| Some ( ( input_218, r ) ) -> Some((input_218, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_215, __2 ) ) -> Some((input_215, 
#186 "ocaml_parser.trx"
( match __2 with
     | None -> None, __1
     | Some x -> Some x, __1
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern) (input) (res)) ; res)
)
and try_Ocaml_parser_Cond_noerr = 
#227 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cond) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_IF_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_658, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_658)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_659, __2 ) ) -> (match (try_Ocaml_keywords_THEN_noerr (_filename) (_text) (input_659)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_660, __3 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_660)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_661, __4 ) ) -> (match (match (match (try_Ocaml_keywords_ELSE_noerr (_filename) (_text) (input_661)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_663, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_663)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_664, __2 ) ) -> Some((input_664, 
#227 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_661, None))
| Some ( ( input_665, r ) ) -> Some((input_665, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_662, __5 ) ) -> Some((input_662, 
#228 "ocaml_parser.trx"
( Cond (__2, __4, match __5 with None -> Const Unit | Some s -> s)  )))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cond) (input) (res)) ; res)
)
and try_Ocaml_parser_SetRef_noerr = 
#222 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SetRef) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_383, __1 ) ) -> (match (try_Ocaml_keywords_GETREF_noerr (_filename) (_text) (input_383)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_384, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_384)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_385, __3 ) ) -> Some((input_385, 
#222 "ocaml_parser.trx"
( SetRef (__1, __3)  )))))) in
(Hashtbl.add (memo_Ocaml_parser_SetRef) (input) (res)) ; res)
)
and try_Ocaml_parser_ExprNotApp_noerr = 
#292 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_ExprNotApp) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_Open_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Module_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Cond_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Letin_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Match_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Exception_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Raise_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Try_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Assert_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_MakeRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_GetRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_SetRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Cons_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_EmptyList_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Abs_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_594, __1 ) ) -> (match (match (match (try_Ocaml_keywords_CONS_noerr (_filename) (_text) (input_594)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_596, __1 ) ) -> (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input_596)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_597, __2 ) ) -> Some((input_597, 
#311 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_594, None))
| Some ( ( input_598, r ) ) -> Some((input_598, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_595, __2 ) ) -> Some((input_595, 
#311 "ocaml_parser.trx"
( match __2 with | None -> __1 | Some x -> Cons (__1, x) ))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_593, __1 ) ) -> Some((input_593, 
#312 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_ExprNotApp) (input) (res)) ; res)
)
and try_Ocaml_parser_LetOrType_noerr = 
#413 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LetOrType) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_513, __1 ) ) -> (match (match (try_Ocaml_parser_Type_noerr (_filename) (_text) (input_513)) with
None -> (try_Ocaml_parser_Let_noerr (_filename) (_text) (input_513))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_514, __2 ) ) -> (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input_514) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_514) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_514) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_514) (2)), ";;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_516, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_516)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_517, __2 ) ) -> Some((input_517, ())))) with
None -> Some((input_514, None))
| Some ( ( input_518, r ) ) -> Some((input_518, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_515, __3 ) ) -> Some((input_515, 
#413 "ocaml_parser.trx"
( __2  )))))) in
(Hashtbl.add (memo_Ocaml_parser_LetOrType) (input) (res)) ; res)
)
and try_Ocaml_parser_matchExpr_noerr = 
#273 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_matchExpr) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_325, __1 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_325)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_326, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_326)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_327, __3 ) ) -> Some((input_327, 
#274 "ocaml_parser.trx"
( match __1 with
     | Some guard, pat -> pat, Some guard, __3
     | None, pat -> pat, None, __3
   )))))) in
(Hashtbl.add (memo_Ocaml_parser_matchExpr) (input) (res)) ; res)
)
and try_Ocaml_parser_Constructor_noerr = 
#200 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Constructor) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_646, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_646)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_647, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_647)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_648, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_648)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_649, __4 ) ) -> Some((input_649, 
#202 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __3 with Tuple l -> l | x -> [x])
     ))))))) with
None -> (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_644, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_644)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_645, __2 ) ) -> Some((input_645, 
#207 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, [__2])
     ))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_641, __1 ) ) -> (match (match (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_641)) with
None -> Some((input_641, None))
| Some ( ( input_643, r ) ) -> Some((input_643, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_642, __2 ) ) -> Some((input_642, 
#214 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __2 with None -> [] | Some s -> [s])
     )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Constructor) (input) (res)) ; res)
)
and try_Ocaml_parser_Letin_noerr = 
#249 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Letin) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_LET_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_495, __1 ) ) -> (match (match (try_Ocaml_keywords_REC_noerr (_filename) (_text) (input_495)) with
None -> Some((input_495, None))
| Some ( ( input_512, r ) ) -> Some((input_512, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_496, __2 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_496)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_497, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_511 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_511)))) (input_497)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_498, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_498)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_499, __5 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_499)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_500, __6 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_504 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_504)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_505, __1 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_505)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_506, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_510 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_510)))) (input_506)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_507, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_507)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_508, __4 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_508)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_509, __5 ) ) -> Some((input_509, 
#250 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )))))))))) (input_500)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_501, __7 ) ) -> (match (try_Ocaml_keywords_IN_noerr (_filename) (_text) (input_501)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_502, __8 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_502)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_503, __9 ) ) -> Some((input_503, 
#252 "ocaml_parser.trx"
( match __2 with Some _ -> let tmp = make_fun __6 __4 in Letrecin ((__3, tmp)::__7, __9)
        | None -> let tmp = make_fun __6 __4 in Letin ((__3, tmp)::__7, __9)
         )))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Letin) (input) (res)) ; res)
)
and try_Ocaml_parser_Raise_noerr = 
#282 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Raise) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_RAISE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_401, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input_401)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_402, __2 ) ) -> (match (match (match (try_Default_lparen_noerr (_filename) (_text) (input_402)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_404, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_404)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_405, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_405)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_406, __3 ) ) -> Some((input_406, 
#282 "ocaml_parser.trx"
( __2 )))))) with
None -> Some((input_402, None))
| Some ( ( input_407, r ) ) -> Some((input_407, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_403, __3 ) ) -> Some((input_403, 
#283 "ocaml_parser.trx"
( Raise ([Ident.source __2], __3)
   )))))) in
(Hashtbl.add (memo_Ocaml_parser_Raise) (input) (res)) ; res)
)
and try_Ocaml_parser_paramFormel_noerr = 
#62 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramFormel) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_261, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_261)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_262, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_262)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_263, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_263)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_266, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_266)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_267, __2 ) ) -> Some((input_267, 
#63 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_263, None))
| Some ( ( input_268, r ) ) -> Some((input_268, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_264, __4 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_264)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_265, __5 ) ) -> Some((input_265, 
#64 "ocaml_parser.trx"
( Label (__3, None, __4)
     )))))))) with
None -> (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_254, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_254)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_255, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_255)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_258, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_258)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_259, __2 ) ) -> Some((input_259, 
#68 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_255, None))
| Some ( ( input_260, r ) ) -> Some((input_260, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_256, __3 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_256)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_257, __4 ) ) -> Some((input_257, 
#69 "ocaml_parser.trx"
( Label (__2, __3, None)
     ))))))) with
None -> (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_244, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_244)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_245, __2 ) ) -> (match (try_Default_colon_noerr (_filename) (_text) (input_245)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_246, __3 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_246)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_247, __4 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_247)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_248, __5 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_248)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_251, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_251)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_252, __2 ) ) -> Some((input_252, 
#73 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_248, None))
| Some ( ( input_253, r ) ) -> Some((input_253, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_249, __6 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_249)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_250, __7 ) ) -> Some((input_250, 
#74 "ocaml_parser.trx"
( Label (__2, Some __5, __6)
     )))))))))) with
None -> (match (match (try_Default_question_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_232, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_232)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_233, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_233)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_234, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_234)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_241, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_241)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_242, __2 ) ) -> Some((input_242, 
#78 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_234, None))
| Some ( ( input_243, r ) ) -> Some((input_243, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_235, __4 ) ) -> (match (match (match (try_Default_equal_noerr (_filename) (_text) (input_235)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_238, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_238)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_239, __2 ) ) -> Some((input_239, 
#78 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_235, None))
| Some ( ( input_240, r ) ) -> Some((input_240, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_236, __5 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_236)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_237, __6 ) ) -> Some((input_237, 
#79 "ocaml_parser.trx"
( Opt (__3, __4, __5)
      ))))))))) with
None -> (match (match (try_Default_question_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_230, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_230)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_231, __2 ) ) -> Some((input_231, 
#83 "ocaml_parser.trx"
( Opt (__2, None, None)  ))))) with
None -> (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_223, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_223)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_224, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_224)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_227, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_227)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_228, __2 ) ) -> Some((input_228, 
#85 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_224, None))
| Some ( ( input_229, r ) ) -> Some((input_229, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_225, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_225)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_226, __4 ) ) -> Some((input_226, 
#86 "ocaml_parser.trx"
( match __3 with
      | None -> Pat (PatVar (Ident.source __2))
      | Some x -> Pat (PatAnnot (PatVar (Ident.source __2), x))
     ))))))) with
None -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_222, __1 ) ) -> Some((input_222, 
#93 "ocaml_parser.trx"
( Pat __1
     ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramFormel) (input) (res)) ; res)
)
and try_Ocaml_parser_Record_noerr = 
#258 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Record) (input))
) with
Not_found -> let res = (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_386, __1 ) ) -> (match (match (try_Ocaml_parser_RNameOpt_noerr (_filename) (_text) (input_386)) with
None -> Some((input_386, None))
| Some ( ( input_400, r ) ) -> Some((input_400, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_387, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_387)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_388, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_388)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_389, __4 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_389)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_390, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_395 -> (match (try_Default_semi_noerr (_filename) (_text) (input_395)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_396, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_396)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_397, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_397)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_398, __3 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_398)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_399, __4 ) ) -> Some((input_399, 
#259 "ocaml_parser.trx"
( __2, __4 ))))))))) (input_390)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_391, __6 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_391)) with
None -> Some((input_391, None))
| Some ( ( input_394, r ) ) -> Some((input_394, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_392, __7 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_392)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_393, __8 ) ) -> Some((input_393, 
#261 "ocaml_parser.trx"
( Record (__2,((__3, __5)::__6))  ))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Record) (input) (res)) ; res)
)
and try_Ocaml_parser_dotable_noerr = 
#321 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_dotable) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Record_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Paren_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_Var_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_dotable) (input) (res)) ; res)
)
and try_Ocaml_parser_Module_noerr = 
#195 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Module) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_MODULE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_449, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_449)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_450, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_463 -> (match (try_Default_lparen_noerr (_filename) (_text) (input_463)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_464, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_464)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_465, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_465)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_468, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_468)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_469, __2 ) ) -> Some((input_469, 
#196 "ocaml_parser.trx"
( Signature (Referenced [__2])  ))))) with
None -> Some((input_465, None))
| Some ( ( input_470, r ) ) -> Some((input_470, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_466, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_466)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_467, __4 ) ) -> Some((input_467, 
#196 "ocaml_parser.trx"
( __2, __3 ))))))))) (input_450)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_451, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_451)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_460, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_460)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_461, __2 ) ) -> Some((input_461, 
#197 "ocaml_parser.trx"
( Signature (Referenced [__2])  ))))) with
None -> Some((input_451, None))
| Some ( ( input_462, r ) ) -> Some((input_462, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_452, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_452)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_453, __5 ) ) -> (match (match (match (try_Ocaml_keywords_STRUCT_noerr (_filename) (_text) (input_453)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_456, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_459 -> (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input_459)))) (input_456)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_457, __2 ) ) -> (match (try_Ocaml_keywords_END_noerr (_filename) (_text) (input_457)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_458, __3 ) ) -> Some((input_458, 
#198 "ocaml_parser.trx"
( __2  )))))) with
None -> (match (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input_453)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_455, __1 ) ) -> Some((input_455, 
#198 "ocaml_parser.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_454, __6 ) ) -> Some((input_454, 
#198 "ocaml_parser.trx"
( match __3 with [] -> Module (__2, __4, __6, None) | _ -> DeclareFunctor (__2, __3, __4, Structure __6)  ))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Module) (input) (res)) ; res)
)
and try_Ocaml_parser_paramEffectif_noerr = 
#98 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramEffectif) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_275, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_275)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_276, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_276)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_279, __1 ) ) -> (match (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_279)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_280, __2 ) ) -> Some((input_280, 
#99 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_276, None))
| Some ( ( input_281, r ) ) -> Some((input_281, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_277, __3 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_277)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_278, __4 ) ) -> Some((input_278, 
#100 "ocaml_parser.trx"
( Labeled (__2, __3)
     ))))))) with
None -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_272 -> (match (try_Ocaml_parser_moduleName__noerr (_filename) (_text) (input_272)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_273, __1 ) ) -> (match if ( (((<)) (input_273) (_len)) ) then ( let c = ((_get_char) (input_273)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_273)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_274, __2 ) ) -> Some((input_274, 
#106 "ocaml_parser.trx"
( __1 ))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_270, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_270)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_271, __2 ) ) -> Some((input_271, 
#107 "ocaml_parser.trx"
( Pated (List.map Ident.source (__1 @ [__2]), false)
     ))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_269, __1 ) ) -> Some((input_269, 
#112 "ocaml_parser.trx"
( Pated (List.map Ident.source __1, true)
     ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramEffectif) (input) (res)) ; res)
)
and try_Ocaml_parser_Abs_noerr = 
#229 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Abs) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (true) ((fun input_679 -> (match (try_Ocaml_keywords_FUN_noerr (_filename) (_text) (input_679)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_680, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_683 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_683)))) (input_680)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_681, __2 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_681)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_682, __3 ) ) -> Some((input_682, 
#229 "ocaml_parser.trx"
( __2 )))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_677, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_677)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_678, __2 ) ) -> Some((input_678, 
#229 "ocaml_parser.trx"
( Abs (List.flatten __1, __2)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Abs) (input) (res)) ; res)
)
and try_Ocaml_parser_Let_noerr = 
#233 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Let) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_LET_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_531, __1 ) ) -> (match (match (try_Ocaml_keywords_REC_noerr (_filename) (_text) (input_531)) with
None -> Some((input_531, None))
| Some ( ( input_537, r ) ) -> Some((input_537, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_532, __2 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_532)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_533, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_536 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_536)))) (input_533)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_534, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_534)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_535, __5 ) ) -> Some((input_535, 
#234 "ocaml_parser.trx"
( __2, __3, __4 )))))))) with
None -> Some((input, None))
| Some ( ( input_538, r ) ) -> Some((input_538, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_521, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_521)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_522, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_524 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_524)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_525, __1 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_525)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_526, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_530 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_530)))) (input_526)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_527, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_527)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_528, __4 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_528)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_529, __5 ) ) -> Some((input_529, 
#236 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )))))))))) (input_522)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_523, __3 ) ) -> Some((input_523, 
#238 "ocaml_parser.trx"
( match __1 with
        | None -> __2
        | Some (_rec, name, pfs) ->
                match _rec with
                | Some _ ->
                        let tmp = make_fun __2 pfs in Letrec ((name, tmp)::__3)
                | None -> let tmp = make_fun __2 pfs in Let ((name, tmp)::__3)
         )))))) in
(Hashtbl.add (memo_Ocaml_parser_Let) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_noerr = 
#333 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_615, __1 ) ) -> (match (match (match (try_Default_semi_noerr (_filename) (_text) (input_615)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_617, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_617)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_618, __2 ) ) -> Some((input_618, 
#333 "ocaml_parser.trx"
( __2  ))))) with
None -> Some((input_615, None))
| Some ( ( input_619, r ) ) -> Some((input_619, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_616, __2 ) ) -> Some((input_616, 
#333 "ocaml_parser.trx"
( match __2 with None -> __1 | Some x -> Sequence (__1, x)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr) (input) (res)) ; res)
)
and try_Ocaml_parser_Assert_noerr = 
#290 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Assert) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_ASSERT_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_666, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_666)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_667, __2 ) ) -> Some((input_667, 
#290 "ocaml_parser.trx"
( Assert __2  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Assert) (input) (res)) ; res)
)
and try_Ocaml_parser_Match_noerr = 
#263 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Match) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MATCH_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_479, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_479)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_480, __2 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_480)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_481, __3 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_481)) with
None -> Some((input_481, None))
| Some ( ( input_488, r ) ) -> Some((input_488, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_482, __4 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_482)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_483, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_485 -> (match (try_Default_bar_noerr (_filename) (_text) (input_485)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_486, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_486)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_487, __2 ) ) -> Some((input_487, 
#264 "ocaml_parser.trx"
( __2  ))))))) (input_483)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_484, __6 ) ) -> Some((input_484, 
#265 "ocaml_parser.trx"
( Match (__2, __5 :: __6)
     ))))))))) with
None -> (match (try_Ocaml_keywords_FUNCTION_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_471, __1 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_471)) with
None -> Some((input_471, None))
| Some ( ( input_478, r ) ) -> Some((input_478, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_472, __2 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_472)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_473, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_475 -> (match (try_Default_bar_noerr (_filename) (_text) (input_475)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_476, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_476)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_477, __2 ) ) -> Some((input_477, 
#268 "ocaml_parser.trx"
( __2  ))))))) (input_473)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_474, __4 ) ) -> Some((input_474, 
#269 "ocaml_parser.trx"
( Function (__3::__4)
     )))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Match) (input) (res)) ; res)
)
let rec try_Default_spacing = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1780 -> (match (match (try_Default_space (_filename) (_text) (input_1780)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1782, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1782, ( () )), ((Trx_runtime.emptyError) (input_1782))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1780)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1781, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1781, __1), ((Trx_runtime.emptyError) (input_1781)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1779, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1779, ( () )), ((Trx_runtime.emptyError) (input_1779))))))) in
(Hashtbl.add (memo_Default_spacing_err) (input) (res)) ; res)
)
let rec try_Default_lparen = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'('")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1844, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1844)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1845, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1845, ( () )), ((Trx_runtime.emptyError) (input_1845)))))))))) in
(Hashtbl.add (memo_Default_lparen_err) (input) (res)) ; res)
)
let rec try_Default_rparen = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("')'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1799, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1799)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1800, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1800, ( () )), ((Trx_runtime.emptyError) (input_1800)))))))))) in
(Hashtbl.add (memo_Default_rparen_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_spacing = 
#20 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1639 -> (match (match (try_Default_space (_filename) (_text) (input_1639)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1641, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1641, ( () )), ((Trx_runtime.emptyError) (input_1641))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1639)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1640, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1640, __1), ((Trx_runtime.emptyError) (input_1640)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1638, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1638, ( () )), ((Trx_runtime.emptyError) (input_1638))))))) in
(Hashtbl.add (memo_Ocaml_keywords_spacing_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_OF = 
#50 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "of")) ) else ( None )) (input) ("\"of\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1670, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1670)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1671, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1671, ( () )), ((Trx_runtime.emptyError) (input_1671)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_OF_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_spacing = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1078 -> (match (match (try_Default_space (_filename) (_text) (input_1078)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1080, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1080, ( () )), ((Trx_runtime.emptyError) (input_1080))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1078)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1079, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1079, __1), ((Trx_runtime.emptyError) (input_1079)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1077, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1077, ( () )), ((Trx_runtime.emptyError) (input_1077))))))) in
(Hashtbl.add (memo_Ocaml_types_spacing_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent_cont = 
#31 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1059, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1059, __1), ((Trx_runtime.emptyError) (input_1059))))))))
let rec try_Ocaml_types_typeconstructor = 
#34 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconstructor_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['A'-'Z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1042, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1044 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1044)))) (input_1042)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1043, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1043, (_get_sub (input) ((((-)) (input_1043) (input))))), ((Trx_runtime.emptyError) (input_1043)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1040, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1040)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1041, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1041, 
#34 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1041)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typeconstructor_err) (input) (res)) ; res)
)
let rec try_Default_rightarrow = 
#86 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rightarrow_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "->")) ) else ( None )) (input) ("\"->\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1801, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1801)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1802, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1802, ( () )), ((Trx_runtime.emptyError) (input_1802)))))))))) in
(Hashtbl.add (memo_Default_rightarrow_err) (input) (res)) ; res)
)
let rec try_Default_laccol = 
#65 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_laccol_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('{')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'{'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1850, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1850)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1851, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1851, ( () )), ((Trx_runtime.emptyError) (input_1851)))))))))) in
(Hashtbl.add (memo_Default_laccol_err) (input) (res)) ; res)
)
let rec try_Default_raccol = 
#66 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_raccol_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('}')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'}'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1805, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1805)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1806, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1806, ( () )), ((Trx_runtime.emptyError) (input_1806)))))))))) in
(Hashtbl.add (memo_Default_raccol_err) (input) (res)) ; res)
)
let rec try_Default_semi = 
#68 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_semi_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("';'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1797, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1797)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1798, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1798, ( () )), ((Trx_runtime.emptyError) (input_1798)))))))))) in
(Hashtbl.add (memo_Default_semi_err) (input) (res)) ; res)
)
let rec try_Default_colon = 
#67 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_colon_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("':'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1880, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1880)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1881, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1881, ( () )), ((Trx_runtime.emptyError) (input_1881)))))))))) in
(Hashtbl.add (memo_Default_colon_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MUTABLE = 
#64 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MUTABLE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )) (input) ("\"mutable\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1672, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1672)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1673, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1673, ( () )), ((Trx_runtime.emptyError) (input_1673)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MUTABLE_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_KEYWORDS = 
#22 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_KEYWORDS_err) (input))
) with
Not_found -> let res = (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'~' -> Some(((((+)) (input) (1)), "~"))
| '}' -> Some(((((+)) (input) (1)), "}"))
| '|' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "||"))
| ']' -> Some(((((+)) (input) (2)), "|]"))
| _ -> Some(((((+)) (input) (1)), "|"))) ) else ( Some(((((+)) (input) (1)), "|")) )
| '{' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (2)), "{<")) ) else ( Some(((((+)) (input) (1)), "{")) )
| 'w' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )
| 'h' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (5)), "while")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'v' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "virtual")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) (true)))) ) then ( Some(((((+)) (input) (3)), "val")) ) else ( None )
| _ -> None) ) else ( None )
| 't' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'y' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )
| 'r' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'y' -> Some(((((+)) (input) (3)), "try"))
| 'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )
| _ -> None) ) else ( None )
| 'o' -> Some(((((+)) (input) (2)), "to"))
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )
| _ -> None) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) (true)))) ) then ( Some(((((+)) (input) (3)), "sig")) ) else ( None )
| _ -> None) ) else ( None )
| 'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('v'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), "private")) ) else ( None )
| 'o' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'r' -> Some(((((+)) (input) (2)), "or"))
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )
| 'f' -> Some(((((+)) (input) (2)), "of"))
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('j'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "object")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('w'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "new")) ) else ( None )
| 'm' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( Some(((((+)) (input) (3)), "mod")) ) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "method")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )
| _ -> None) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'z' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('y'))) (true)))) ) then ( Some(((((+)) (input) (4)), "lazy")) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'i' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'n' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (11))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('z'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (10))))) ('r'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (11)), "initializer")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "inherit")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "include")) ) else ( Some(((((+)) (input) (2)), "in")) )
| _ -> Some(((((+)) (input) (2)), "in"))) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'f' -> Some(((((+)) (input) (2)), "if"))
| _ -> None) ) else ( None )
| 'f' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))) ) then ( if ( (((<)) ((((+)) (input) (5))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (5)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (7)), "functor")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| _ -> Some(((((+)) (input) (3)), "fun"))) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "for")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )
| _ -> None) ) else ( None )
| 'e' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (8)), "external")) ) else ( None )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )
| _ -> None) ) else ( None )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) (true)))) ) then ( if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'w' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('o'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "downto")) ) else ( Some(((((+)) (input) (2)), "do")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "done")) ) else ( Some(((((+)) (input) (2)), "do")) )
| _ -> Some(((((+)) (input) (2)), "do"))) ) else ( Some(((((+)) (input) (2)), "do")) ) ) else ( None )
| 'c' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (10))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('t'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (10)), "constraint")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "class")) ) else ( None )
| _ -> None) ) else ( None )
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
's' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'r' -> Some(((((+)) (input) (3)), "asr"))
| _ -> Some(((((+)) (input) (2)), "as"))) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )
| _ -> None) ) else ( None )
| '`' -> Some(((((+)) (input) (1)), "`"))
| '_' -> Some(((((+)) (input) (1)), "_"))
| ']' -> Some(((((+)) (input) (1)), "]"))
| '[' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "[|"))
| '>' -> Some(((((+)) (input) (2)), "[>"))
| '<' -> Some(((((+)) (input) (2)), "[<"))
| _ -> Some(((((+)) (input) (1)), "["))) ) else ( Some(((((+)) (input) (1)), "[")) )
| '?' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) (true)))) ) then ( Some(((((+)) (input) (2)), "??")) ) else ( Some(((((+)) (input) (1)), "?")) )
| '>' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'}' -> Some(((((+)) (input) (2)), ">}"))
| ']' -> Some(((((+)) (input) (2)), ">]"))
| _ -> Some(((((+)) (input) (1)), ">"))) ) else ( Some(((((+)) (input) (1)), ">")) )
| '=' -> Some(((((+)) (input) (1)), "="))
| '<' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( Some(((((+)) (input) (1)), "<")) )
| ';' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (';'))) (true)))) ) then ( Some(((((+)) (input) (2)), ";;")) ) else ( Some(((((+)) (input) (1)), ";")) )
| ':' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), ":>"))
| '=' -> Some(((((+)) (input) (2)), ":="))
| ':' -> Some(((((+)) (input) (2)), "::"))
| _ -> Some(((((+)) (input) (1)), ":"))) ) else ( Some(((((+)) (input) (1)), ":")) )
| '.' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))) ) then ( Some(((((+)) (input) (2)), "..")) ) else ( Some(((((+)) (input) (1)), ".")) )
| '-' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), "->"))
| '.' -> Some(((((+)) (input) (2)), "-."))
| _ -> Some(((((+)) (input) (1)), "-"))) ) else ( Some(((((+)) (input) (1)), "-")) )
| ',' -> Some(((((+)) (input) (1)), ","))
| '+' -> Some(((((+)) (input) (1)), "+"))
| '*' -> Some(((((+)) (input) (1)), "*"))
| ')' -> Some(((((+)) (input) (1)), ")"))
| '(' -> Some(((((+)) (input) (1)), "("))
| '\'' -> Some(((((+)) (input) (1)), "'"))
| '&' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( Some(((((+)) (input) (1)), "&")) )
| '#' -> Some(((((+)) (input) (1)), "#"))
| _ -> None) ) else ( None )) (input) ("\"#\" or \"&\" or \"&&\" or \"'\" or \"(\" or \")\" or \"*\" or \"+\" or \",\" or \"-\" or \"-.\" or \"->\" or \".\" or \"..\" or \":\" or \"::\" or \":=\" or \":>\" or \";\" or \";;\" or \"<\" or \"<-\" or \"=\" or \">\" or \">]\" or \">}\" or \"?\" or \"??\" or \"[\" or \"[<\" or \"[>\" or \"[|\" or \"]\" or \"_\" or \"`\" or \"and\" or \"as\" or \"asr\" or \"begin\" or \"class\" or \"constraint\" or \"do\" or \"done\" or \"downto\" or \"else\" or \"end\" or \"exception\" or \"external\" or \"false\" or \"for\" or \"fun\" or \"function\" or \"functor\" or \"if\" or \"in\" or \"include\" or \"inherit\" or \"initializer\" or \"land\" or \"lazy\" or \"let\" or \"lor\" or \"lsl\" or \"lsr\" or \"lxor\" or \"match\" or \"method\" or \"mod\" or \"module\" or \"mutable\" or \"new\" or \"object\" or \"of\" or \"open\" or \"or\" or \"private\" or \"rec\" or \"sig\" or \"struct\" or \"then\" or \"to\" or \"true\" or \"try\" or \"type\" or \"val\" or \"virtual\" or \"when\" or \"while\" or \"with\" or \"{\" or \"{<\" or \"|\" or \"|]\" or \"||\" or \"}\" or \"~\" or \"assert\"")) in
(Hashtbl.add (memo_Ocaml_keywords_KEYWORDS_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent_aux = 
#32 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_aux_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['a'-'z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1063, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1065 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1065)))) (input_1063)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1064, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1064, (_get_sub (input) ((((-)) (input_1064) (input))))), ((Trx_runtime.emptyError) (input_1064)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'_'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1060, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1062 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1062)))) (input_1060)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1061, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1061, (_get_sub (input) ((((-)) (input_1061) (input))))), ((Trx_runtime.emptyError) (input_1061))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_aux_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeIdent = 
#33 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1069, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1069)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1070 = input_1069 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1070, __1), ((Trx_runtime.emptyError) (input_1070))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1066 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_aux (_filename) (_text) (input_1066)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1067, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1067)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1068, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1068, 
#33 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1068))))))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_BoolT = 
#29 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "bool")) ) else ( None )) (input) ("\"bool\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1100, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1100, 
#29 "ocaml_types.trx"
( TypeBool  )), ((Trx_runtime.emptyError) (input_1100))))))))
let rec try_Ocaml_types_CharT = 
#28 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "char")) ) else ( None )) (input) ("\"char\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1099, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1099, 
#28 "ocaml_types.trx"
( TypeChar  )), ((Trx_runtime.emptyError) (input_1099))))))))
let rec try_Ocaml_types_FloatT = 
#25 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "float")) ) else ( None )) (input) ("\"float\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1098, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1098, 
#25 "ocaml_types.trx"
( TypeFloat  )), ((Trx_runtime.emptyError) (input_1098))))))))
let rec try_Ocaml_types_Int64T = 
#24 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('6'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('4'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "int64")) ) else ( None )) (input) ("\"int64\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1097, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1097, 
#24 "ocaml_types.trx"
( TypeInt64  )), ((Trx_runtime.emptyError) (input_1097))))))))
let rec try_Ocaml_types_IntT = 
#23 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "int")) ) else ( None )) (input) ("\"int\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1096, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1096, 
#23 "ocaml_types.trx"
( TypeInt  )), ((Trx_runtime.emptyError) (input_1096))))))))
let rec try_Ocaml_types_StringT = 
#26 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('g'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "string")) ) else ( None )) (input) ("\"string\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1095, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1095, 
#26 "ocaml_types.trx"
( TypeString  )), ((Trx_runtime.emptyError) (input_1095))))))))
let rec try_Ocaml_types_UnitT = 
#27 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "unit")) ) else ( None )) (input) ("\"unit\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1094, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1094, 
#27 "ocaml_types.trx"
( TypeUnit  )), ((Trx_runtime.emptyError) (input_1094))))))))
let rec try_Ocaml_types_typeconst = 
#22 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconst_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_types_IntT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1052, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1052, __1), ((Trx_runtime.emptyError) (input_1052))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_Int64T (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1051, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1051, __1), ((Trx_runtime.emptyError) (input_1051))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_FloatT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1050, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1050, __1), ((Trx_runtime.emptyError) (input_1050))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_StringT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1049, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1049, __1), ((Trx_runtime.emptyError) (input_1049))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_UnitT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1048, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1048, __1), ((Trx_runtime.emptyError) (input_1048))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_CharT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1047, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1047, __1), ((Trx_runtime.emptyError) (input_1047))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_BoolT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1046, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1046, __1), ((Trx_runtime.emptyError) (input_1046)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1045, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1045, 
#22 "ocaml_types.trx"
( TypeConst __1  )), ((Trx_runtime.emptyError) (input_1045))))))) in
(Hashtbl.add (memo_Ocaml_types_typeconst_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typename = 
#36 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typename_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeconstructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_991, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_991) (_len)) ) then ( let c = ((_get_char) (input_991)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_991)), c)) ) else ( None ) ) else ( None )) (input_991) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_992, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typename (_filename) (_text) (input_992)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_993, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_993, 
#36 "ocaml_types.trx"
( __1 :: __3  )), ((Trx_runtime.emptyError) (input_993))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_990, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_990, 
#37 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_990)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typename_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevar = 
#35 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevar_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_969, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_969)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_970, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_970, 
#35 "ocaml_types.trx"
( TypeVar ("'" ^ __2)  )), ((Trx_runtime.emptyError) (input_970)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typevar_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevarorname = 
#46 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevarorname_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_968, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_968, __1), ((Trx_runtime.emptyError) (input_968))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_types_typeconst (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_966, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_966)) with
Trx_runtime.Fail ( ( err ) ) -> let input_967 = input_966 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_967, __1), ((Trx_runtime.emptyError) (input_967))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_964 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typename (_filename) (_text) (input_964)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_965, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_965, 
#46 "ocaml_types.trx"
( TypeName ([], __2)  )), ((Trx_runtime.emptyError) (input_965)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeconst (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_962, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_962)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_963, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_963, 
#46 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_963))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevarorname_err) (input) (res)) ; res)
)
let rec try_Default_comma = 
#63 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_comma_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("','")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1878, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1878)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1879, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1879, ( () )), ((Trx_runtime.emptyError) (input_1879)))))))))) in
(Hashtbl.add (memo_Default_comma_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedef_base = 
#65 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_base_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeSum (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1017, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1017, __1), ((Trx_runtime.emptyError) (input_1017))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typerecord (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1016, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1016, __1), ((Trx_runtime.emptyError) (input_1016))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevarorname (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1015, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1015, __1), ((Trx_runtime.emptyError) (input_1015))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1012, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1012)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1013, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1013)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1014, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1014, 
#67 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1014)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_base_err) (input) (res)) ; res)
)
and try_Ocaml_types_typeSum = 
#98 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeSum_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeconstructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1053, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1053) (_len)) ) then ( let c = ((_get_char) (input_1053)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1053)), c)) ) else ( None ) ) else ( None )) (input_1053) (((Trx_runtime.Expected(("'.'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1054 = input_1053 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_OF (_filename) (_text) (input_1054)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1056, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1056)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1057, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1057, 
#98 "ocaml_types.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1057)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1054, None), err))
| Trx_runtime.Ok ( ( ( input_1058, r ), err ) ) -> Trx_runtime.Ok(((input_1058, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1055, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1055, 
#98 "ocaml_types.trx"
( TypeConstructor [__1, __3]  )), ((Trx_runtime.emptyError) (input_1055)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) in
(Hashtbl.add (memo_Ocaml_types_typeSum_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_no_arrow = 
#82 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_no_arrow_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1006, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1008 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1008) (_len)) ) then ( let c = ((_get_char) (input_1008)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input_1008)), c)) ) else ( None ) ) else ( None )) (input_1008) (((Trx_runtime.Expected(("'*'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1009, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1009)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1010, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_aux (_filename) (_text) (input_1010)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1011, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1011, 
#82 "ocaml_types.trx"
( __3 )), ((Trx_runtime.emptyError) (input_1011))))))))))))))) (input_1006)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1007, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1007, 
#82 "ocaml_types.trx"
( match (__1::__2) with
    | [] -> error "@Ocaml_types.typedef_no_arrow : empty type tuple"
    | [td] -> td
    | tdl -> TypeTuple tdl
 )), ((Trx_runtime.emptyError) (input_1007)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedef_no_arrow_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef = 
#89 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typedef_no_arrow (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1023, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1023)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1024, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1024)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1025, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1025, 
#90 "ocaml_types.trx"
( TypeArrow ( __1, __3)  )), ((Trx_runtime.emptyError) (input_1025))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_no_arrow (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1022, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1022, 
#91 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1022)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_err) (input) (res)) ; res)
)
and try_Ocaml_types_onetyperecord = 
#95 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_onetyperecord_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MUTABLE (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1085, r ), err ) ) -> Trx_runtime.Ok(((input_1085, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1081, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1081)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1082, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_colon (_filename) (_text) (input_1082)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1083, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1083)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1084, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1084, 
#95 "ocaml_types.trx"
( (match __1 with None -> false | _ -> true), __2, __4  )), ((Trx_runtime.emptyError) (input_1084)))))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_onetyperecord_err) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_aux = 
#96 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_onetyperecord (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_971, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_975 -> (match (try_Default_semi (_filename) (_text) (input_975)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_976, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_onetyperecord (_filename) (_text) (input_976)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_977, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_977, 
#96 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_977)))))))))))) (input_971)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_972, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_972)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_972, None), err))
| Trx_runtime.Ok ( ( ( input_974, r ), err ) ) -> Trx_runtime.Ok(((input_974, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_973, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_973, 
#96 "ocaml_types.trx"
( __1 ::__2  )), ((Trx_runtime.emptyError) (input_973))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_aux_err) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord = 
#102 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_err) (input))
) with
Not_found -> let res = (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_978, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typerecord_aux (_filename) (_text) (input_978)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_981, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_981, 
#102 "ocaml_types.trx"
( TypeRecord __1  )), ((Trx_runtime.emptyError) (input_981))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_979, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_979)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_980, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_980, 
#101 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_980))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_err) (input) (res)) ; res)
)
and try_Ocaml_types_typeparam = 
#69 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeparam_err) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_983, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_983)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_984, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_987 -> (match (try_Default_comma (_filename) (_text) (input_987)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_988, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_988)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_989, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_989, 
#70 "ocaml_types.trx"
( __2 )), ((Trx_runtime.emptyError) (input_989)))))))))))) (input_984)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_985, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_985)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_986, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_986, 
#70 "ocaml_types.trx"
( __2 :: __3  )), ((Trx_runtime.emptyError) (input_986)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_base (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_982, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_982, 
#71 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_982)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeparam_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_aux = 
#73 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_aux_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeparam (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1019, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1021 -> (try_Ocaml_types_typename (_filename) (_text) (input_1021)))) (input_1019)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1020, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1020, 
#74 "ocaml_types.trx"
( match __2 with
| hd :: tl -> 
  List.fold_left (fun acc x -> TypeName ([acc], x)) (TypeName (__1, hd)) tl 
| _ -> assert false
 )), ((Trx_runtime.emptyError) (input_1020)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_base (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1018, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1018, __1), ((Trx_runtime.emptyError) (input_1018)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_aux_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_and = 
#380 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_and_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('&'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( None )) (input) ("\"&&\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1254, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1254)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1255, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1255, 
#380 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1255)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_and_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_GETREF = 
#78 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_GETREF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ":=")) ) else ( None )) (input) ("\":=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1684, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1684)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1685, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1685, ( () )), ((Trx_runtime.emptyError) (input_1685)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_GETREF_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_or = 
#381 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_or_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'|' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))) ) then ( Some(((((+)) (input) (2)), "||")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (2)), "or")) ) else ( None )
| _ -> None) ) else ( None )) (input) ("\"or\" or \"||\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1238, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1238)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1239, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1239, 
#381 "ocaml_parser.trx"
( "||"  )), ((Trx_runtime.emptyError) (input_1239)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_or_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel1 = 
#354 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel1_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_op_and (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1518, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1518, __1), ((Trx_runtime.emptyError) (input_1518))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_or (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1517, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1517, __1), ((Trx_runtime.emptyError) (input_1517)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1516, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1516, 
#355 "ocaml_parser.trx"
( Ocaml.make_Var __1
   )), ((Trx_runtime.emptyError) (input_1516))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel1_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_GE = 
#396 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ">=")) ) else ( None )) (input) ("\">=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1531, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1531)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1532, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1532, 
#396 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1532)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GE_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_GT = 
#394 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) (true)))) ) then ( Some(((((+)) (input) (1)), ">")) ) else ( None )) (input) ("\">\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1529, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1529)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1530, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1530, 
#394 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1530)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GT_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_LE = 
#395 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<=")) ) else ( None )) (input) ("\"<=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1495, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1495)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1496, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1496, 
#395 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1496)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LE_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_LT = 
#393 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (1)), "<")) ) else ( None )) (input) ("\"<\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1493, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1493)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1494, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1494, 
#393 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1494)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LT_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_equal = 
#382 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input) (1)), "=")) ) else ( None )) (input) ("\"=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1248, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1248)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1249, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1249, 
#382 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1249)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_notequal = 
#385 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<>")) ) else ( None )) (input) ("\"<>\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1242, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1242)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1243, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1243, 
#385 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1243)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_notequal_struct = 
#384 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_struct_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "!=")) ) else ( None )) (input) ("\"!=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1240, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1240)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1241, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1241, 
#384 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1241)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_struct_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_SPECIALS = 
#39 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_SPECIALS_err) (input))
) with
Not_found -> let res = (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'm' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "mod")) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )) (input) ("\"land\" or \"lor\" or \"lsl\" or \"lsr\" or \"lxor\" or \"mod\"")) in
(Hashtbl.add (memo_Ocaml_keywords_SPECIALS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_special = 
#391 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_special_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_SPECIALS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1236, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1236)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1237, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1237, 
#391 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1237)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_special_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel2 = 
#359 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel2_err) (input))
) with
Not_found -> let res = (match (match (match (match (try_Ocaml_parser_op_equal_struct (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1515, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1515, __1), ((Trx_runtime.emptyError) (input_1515))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_equal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1514, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1514, __1), ((Trx_runtime.emptyError) (input_1514))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_notequal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1513, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1513, __1), ((Trx_runtime.emptyError) (input_1513))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_notequal_struct (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1512, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1512, __1), ((Trx_runtime.emptyError) (input_1512))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_LE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1511, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1511, __1), ((Trx_runtime.emptyError) (input_1511))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_GE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1510, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1510, __1), ((Trx_runtime.emptyError) (input_1510))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_LT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1509, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1509, __1), ((Trx_runtime.emptyError) (input_1509))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_GT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1508, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1508, __1), ((Trx_runtime.emptyError) (input_1508)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1507, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1507, 
#361 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1507))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_special (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1506, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1506, 
#366 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1506)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel2_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FMINUS = 
#409 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMINUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "-.")) ) else ( None )) (input) ("\"-.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1537, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1537)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1538, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1538, 
#409 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1538)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FMINUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IMINUS = 
#404 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMINUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (1)), "-")) ) else ( None )) (input) ("\"-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1523, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1523)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1524, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1524, 
#404 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1524)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IMINUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_MINUS = 
#399 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MINUS_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FMINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1448, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1448, __1), ((Trx_runtime.emptyError) (input_1448))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IMINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1447, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1447, __1), ((Trx_runtime.emptyError) (input_1447)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MINUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FPLUS = 
#408 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FPLUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "+.")) ) else ( None )) (input) ("\"+.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1533, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1533)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1534, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1534, 
#408 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1534)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FPLUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IPLUS = 
#403 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IPLUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) (true)))) ) then ( Some(((((+)) (input) (1)), "+")) ) else ( None )) (input) ("\"+\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1519, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1519)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1520, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1520, 
#403 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1520)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IPLUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_PLUS = 
#398 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_PLUS_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FPLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1376, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1376, __1), ((Trx_runtime.emptyError) (input_1376))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IPLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1375, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1375, __1), ((Trx_runtime.emptyError) (input_1375)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_PLUS_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_aro = 
#388 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_aro_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('@'))) (true)))) ) then ( Some(((((+)) (input) (1)), "@")) ) else ( None )) (input) ("\"@\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1252, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1252)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1253, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1253, 
#388 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1253)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_aro_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_concat = 
#387 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_concat_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input) (1)), "^")) ) else ( None )) (input) ("\"^\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1250, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1250)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1251, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1251, 
#387 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1251)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_concat_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_op_logic = 
#389 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_logic_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "asr")) ) else ( None )) (input) ("\"asr\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1244, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1244)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1245, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1245, 
#389 "ocaml_parser.trx"
( "asr"  )), ((Trx_runtime.emptyError) (input_1245)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_logic_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel3 = 
#370 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel3_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_PLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1505, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1505, __1), ((Trx_runtime.emptyError) (input_1505))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_MINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1504, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1504, __1), ((Trx_runtime.emptyError) (input_1504))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_concat (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1503, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1503, __1), ((Trx_runtime.emptyError) (input_1503))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_aro (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1502, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1502, __1), ((Trx_runtime.emptyError) (input_1502))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_logic (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1501, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1501, __1), ((Trx_runtime.emptyError) (input_1501)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1500, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1500, 
#371 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1500))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel3_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_CONS = 
#79 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_CONS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "::")) ) else ( None )) (input) ("\"::\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1704, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1704)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1705, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1705, ( () )), ((Trx_runtime.emptyError) (input_1705)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_CONS_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_FUN = 
#41 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "fun")) ) else ( None )) (input) ("\"fun\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1688, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1688)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1689, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1689, ( () )), ((Trx_runtime.emptyError) (input_1689)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUN_err) (input) (res)) ; res)
)
let rec try_Default_equal = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_equal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'='")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1871, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1871)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1872, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1872, ( () )), ((Trx_runtime.emptyError) (input_1872)))))))))) in
(Hashtbl.add (memo_Default_equal_err) (input) (res)) ; res)
)
let rec try_Default_question = 
#76 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_question_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'?'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1808, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1808)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1809, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1809, ( () )), ((Trx_runtime.emptyError) (input_1809)))))))))) in
(Hashtbl.add (memo_Default_question_err) (input) (res)) ; res)
)
let rec try_Default_tilde_ = 
#83 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'~'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1720, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1720, ( () )), ((Trx_runtime.emptyError) (input_1720))))))))
let rec try_Ocaml_parser_mlIdent_cont = 
#50 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((=)) (c) ('_'))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('\'')))))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'''")) ; Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1258, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1258, __1), ((Trx_runtime.emptyError) (input_1258))))))))
let rec try_Ocaml_parser_mlIdent_aux_ = 
#51 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1260, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1262 -> (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1262)))) (input_1260)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1261, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1261, (_get_sub (input) ((((-)) (input_1261) (input))))), ((Trx_runtime.emptyError) (input_1261)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1259, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1259, 
#51 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1259))))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux__err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent_aux = 
#52 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_aux_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1263, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1263)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1264, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1264, 
#52 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1264)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent = 
#53 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1277, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1277)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1278 = input_1277 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1278, __1), ((Trx_runtime.emptyError) (input_1278))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1275 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_aux (_filename) (_text) (input_1275)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1276, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1276, 
#53 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1276)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1269, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1269) (_len)) ) then ( let c = ((_get_char) (input_1269)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_1269)), c)) ) else ( None ) ) else ( None )) (input_1269) ([ Trx_runtime.Expected(("'!'")) ; Trx_runtime.Expected(("'$'")) ; Trx_runtime.Expected(("'%'")) ; Trx_runtime.Expected(("'&'")) ; Trx_runtime.Expected(("'*'")) ; Trx_runtime.Expected(("'/'")) ; Trx_runtime.Expected(("':'")) ; Trx_runtime.Expected(("'<'")) ; Trx_runtime.Expected(("'='")) ; Trx_runtime.Expected(("'>'")) ; Trx_runtime.Expected(("'?'")) ; Trx_runtime.Expected(("'@'")) ; Trx_runtime.Expected(("'^'")) ; Trx_runtime.Expected(("'|'")) ; Trx_runtime.Expected(("'~'")) ; Trx_runtime.Expected(("['+'-'.']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1272, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1274 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1274) (_len)) ) then ( let c = ((_get_char) (input_1274)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_1274)), c)) ) else ( None ) ) else ( None )) (input_1274) ([ Trx_runtime.Expected(("'!'")) ; Trx_runtime.Expected(("'$'")) ; Trx_runtime.Expected(("'%'")) ; Trx_runtime.Expected(("'&'")) ; Trx_runtime.Expected(("'*'")) ; Trx_runtime.Expected(("'/'")) ; Trx_runtime.Expected(("':'")) ; Trx_runtime.Expected(("'<'")) ; Trx_runtime.Expected(("'='")) ; Trx_runtime.Expected(("'>'")) ; Trx_runtime.Expected(("'?'")) ; Trx_runtime.Expected(("'@'")) ; Trx_runtime.Expected(("'^'")) ; Trx_runtime.Expected(("'|'")) ; Trx_runtime.Expected(("'~'")) ; Trx_runtime.Expected(("['+'-'.']")) ])))) (input_1272)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1273, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1273, (_get_sub (input_1269) ((((-)) (input_1273) (input_1269))))), ((Trx_runtime.emptyError) (input_1273)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1270, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1270)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1271, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1271, 
#55 "ocaml_parser.trx"
( sprintf "(%s)" __2  )), ((Trx_runtime.emptyError) (input_1271)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_mlIdent_ = 
#56 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent__err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1267, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1267)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1268 = input_1267 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1268, __1), ((Trx_runtime.emptyError) (input_1268))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1265 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_aux_ (_filename) (_text) (input_1265)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1266, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1266, 
#56 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1266)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent__err) (input) (res)) ; res)
)
let rec try_Default_lbracket = 
#71 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lbracket_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('[')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'['")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1848, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1848)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1849, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1849, ( () )), ((Trx_runtime.emptyError) (input_1849)))))))))) in
(Hashtbl.add (memo_Default_lbracket_err) (input) (res)) ; res)
)
let rec try_Default_rbracket = 
#72 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rbracket_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (']')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("']'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1803, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1803)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1804, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1804, ( () )), ((Trx_runtime.emptyError) (input_1804)))))))))) in
(Hashtbl.add (memo_Default_rbracket_err) (input) (res)) ; res)
)
let rec try_Default_underscore = 
#82 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_underscore_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'_'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1716, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1716)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1717, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1717, ( () )), ((Trx_runtime.emptyError) (input_1717)))))))))) in
(Hashtbl.add (memo_Default_underscore_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_AS = 
#51 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "as")) ) else ( None )) (input) ("\"as\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1710, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1710)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1711, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1711, ( () )), ((Trx_runtime.emptyError) (input_1711)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_AS_err) (input) (res)) ; res)
)
let rec try_Default_stringcharspecial = 
#33 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringcharspecial_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('n')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'n'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1751, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1751, 
#34 "default.trx"
( '\n'  )), ((Trx_runtime.emptyError) (input_1751))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('r')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'r'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1750, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1750, 
#34 "default.trx"
( '\r'  )), ((Trx_runtime.emptyError) (input_1750))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('t')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'t'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1749, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1749, 
#34 "default.trx"
( '\t'  )), ((Trx_runtime.emptyError) (input_1749))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1748, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1748, 
#35 "default.trx"
( '\''  )), ((Trx_runtime.emptyError) (input_1748))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1747, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1747, 
#35 "default.trx"
( '\"'  )), ((Trx_runtime.emptyError) (input_1747))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1746, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1746, 
#35 "default.trx"
( '\\'  )), ((Trx_runtime.emptyError) (input_1746))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1745 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1745) (_len)) ) then ( let c = ((_get_char) (input_1745)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1745)), c)) ) else ( None ) ) else ( None )) (input_1745) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1744, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1744, 
#36 "default.trx"
( char_of_int (Tgrammar.int_of_chars __1)  )), ((Trx_runtime.emptyError) (input_1744)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringcharspecial_err) (input) (res)) ; res)
)
let rec try_Default_singlequotechar_ = 
#40 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_singlequotechar__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1788, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_stringcharspecial (_filename) (_text) (input_1788)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1789, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1789, 
#41 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1789)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('\'')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'''")) ; Trx_runtime.Expected(("'\\'")) ])) with
Trx_runtime.Fail ( ( err ) ) -> let input_1786 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1786) (_len)) ) then ( let c = ((_get_char) (input_1786)) in
Some((((succ) (input_1786)), c)) ) else ( None )) (input_1786) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1787, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1787, __2), ((Trx_runtime.emptyError) (input_1787)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_singlequotechar__err) (input) (res)) ; res)
)
let rec try_Default_charsinglequote = 
#46 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_charsinglequote_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1882, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_singlequotechar_ (_filename) (_text) (input_1882)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1883, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1883) (_len)) ) then ( let c = ((_get_char) (input_1883)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_1883)), c)) ) else ( None ) ) else ( None )) (input_1883) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1884, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1884, 
#46 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1884))))))))))))) in
(Hashtbl.add (memo_Default_charsinglequote_err) (input) (res)) ; res)
)
let rec try_Default_strfloat = 
#97 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strfloat_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1770, r ), err ) ) -> Trx_runtime.Ok(((input_1770, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1758, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary_nores (true) ((fun input_1769 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1769) (_len)) ) then ( let c = ((_get_char) (input_1769)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1769)), c)) ) else ( None ) ) else ( None )) (input_1769) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1758)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1765, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1765) (_len)) ) then ( let c = ((_get_char) (input_1765)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1765)), c)) ) else ( None ) ) else ( None )) (input_1765) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1766, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1768 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1768) (_len)) ) then ( let c = ((_get_char) (input_1768)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1768)), c)) ) else ( None ) ) else ( None )) (input_1768) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1766)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1767, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1767, ()), ((Trx_runtime.emptyError) (input_1767))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1764 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1764) (_len)) ) then ( let c = ((_get_char) (input_1764)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1764)), c)) ) else ( None ) ) else ( None )) (input_1764) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1758)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1760, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1760) (_len)) ) then ( let c = ((_get_char) (input_1760)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1760)), c)) ) else ( None ) ) else ( None )) (input_1760) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1761, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1763 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1763) (_len)) ) then ( let c = ((_get_char) (input_1763)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1763)), c)) ) else ( None ) ) else ( None )) (input_1763) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1761)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1762, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1762, ()), ((Trx_runtime.emptyError) (input_1762)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1759, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1759, (_get_sub (input) ((((-)) (input_1759) (input))))), ((Trx_runtime.emptyError) (input_1759)))))))))) in
(Hashtbl.add (memo_Default_strfloat_err) (input) (res)) ; res)
)
let rec try_Default_float = 
#98 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_float_err) (input))
) with
Not_found -> let res = (match (try_Default_strfloat (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1870, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1870, 
#98 "default.trx"
( float_of_string __1  )), ((Trx_runtime.emptyError) (input_1870))))))) in
(Hashtbl.add (memo_Default_float_err) (input) (res)) ; res)
)
let rec try_Default_strint = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strint_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1728, r ), err ) ) -> Trx_runtime.Ok(((input_1728, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1725, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1727 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1727) (_len)) ) then ( let c = ((_get_char) (input_1727)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1727)), c)) ) else ( None ) ) else ( None )) (input_1727) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1725)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1726, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1726, (_get_sub (input) ((((-)) (input_1726) (input))))), ((Trx_runtime.emptyError) (input_1726)))))))))) in
(Hashtbl.add (memo_Default_strint_err) (input) (res)) ; res)
)
let rec try_Default_int = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_int_err) (input))
) with
Not_found -> let res = (match (try_Default_strint (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1865, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1865, 
#95 "default.trx"
( int_of_string __1  )), ((Trx_runtime.emptyError) (input_1865))))))) in
(Hashtbl.add (memo_Default_int_err) (input) (res)) ; res)
)
let rec try_Default_stringchar = 
#37 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringchar_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1754, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_stringcharspecial (_filename) (_text) (input_1754)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1755, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1755, 
#38 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1755)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('"')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\"'")) ; Trx_runtime.Expected(("'\\'")) ])) with
Trx_runtime.Fail ( ( err ) ) -> let input_1752 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1752) (_len)) ) then ( let c = ((_get_char) (input_1752)) in
Some((((succ) (input_1752)), c)) ) else ( None )) (input_1752) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1753, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1753, __2), ((Trx_runtime.emptyError) (input_1753)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringchar_err) (input) (res)) ; res)
)
let rec try_Default_stringnosp = 
#28 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringnosp_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1740, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1743 -> (try_Default_stringchar (_filename) (_text) (input_1743)))) (input_1740)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1741, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1741) (_len)) ) then ( let c = ((_get_char) (input_1741)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_1741)), c)) ) else ( None ) ) else ( None )) (input_1741) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1742, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1742, 
#28 "default.trx"
( Tgrammar.string_of_chars __2  )), ((Trx_runtime.emptyError) (input_1742))))))))))))) in
(Hashtbl.add (memo_Default_stringnosp_err) (input) (res)) ; res)
)
let rec try_Default_string = 
#27 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_string_err) (input))
) with
Not_found -> let res = (match (try_Default_stringnosp (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1756, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1756)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1757, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1757, 
#27 "default.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1757)))))))))) in
(Hashtbl.add (memo_Default_string_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_unit = 
#38 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_unit_err) (input))
) with
Not_found -> let res = (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1101, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1101)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1102, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1102)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1103, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1103, ( () )), ((Trx_runtime.emptyError) (input_1103))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_unit_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_const = 
#39 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_const_err) (input))
) with
Not_found -> let res = (match (match (try_Default_float (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1306, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1306)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1307, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1307, 
#40 "ocaml_parser.trx"
( Float __1  )), ((Trx_runtime.emptyError) (input_1307)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_int (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1304, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1304)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1305, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1305, 
#41 "ocaml_parser.trx"
( Int __1  )), ((Trx_runtime.emptyError) (input_1305)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_string (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1302, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1302)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1303, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1303, 
#42 "ocaml_parser.trx"
( String __1  )), ((Trx_runtime.emptyError) (input_1303)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_charsinglequote (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1300, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1300)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1301, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1301, 
#44 "ocaml_parser.trx"
( Char (__1)  )), ((Trx_runtime.emptyError) (input_1301)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_unit (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1299, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1299, 
#45 "ocaml_parser.trx"
( Unit  )), ((Trx_runtime.emptyError) (input_1299))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )) (input) ("\"false\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1297, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1297)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1298, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1298, 
#46 "ocaml_parser.trx"
( Bool false  )), ((Trx_runtime.emptyError) (input_1298)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )) (input) ("\"true\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1295, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1295)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1296, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1296, 
#47 "ocaml_parser.trx"
( Bool true  )), ((Trx_runtime.emptyError) (input_1296))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_const_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_capMlIdent_ = 
#116 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('`'))) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'`'")) ; Trx_runtime.Expected(("['A'-'Z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1309, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1311 -> (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1311)))) (input_1309)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1310, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1310, (_get_sub (input) ((((-)) (input_1310) (input))))), ((Trx_runtime.emptyError) (input_1310)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1308, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1308, __1), ((Trx_runtime.emptyError) (input_1308))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent__err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_constructorName = 
#121 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_constructorName_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (false) ((fun input_1292 -> (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1292)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1293, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1293) (_len)) ) then ( let c = ((_get_char) (input_1293)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1293)), c)) ) else ( None ) ) else ( None )) (input_1293) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1294, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1294, 
#121 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1294)))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1288, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1288)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1289, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1289) (_len)) ) then ( let c = ((_get_char) (input_1289)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1289)), c)) ) else ( None ) ) else ( None )) (input_1289) (((Trx_runtime.Expected(("'.'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1290 = input_1289 in
let __3 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1290)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1291, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1291, 
#121 "ocaml_parser.trx"
( __1 @ [__2]  )), ((Trx_runtime.emptyError) (input_1291)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))))))) in
(Hashtbl.add (memo_Ocaml_parser_constructorName_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_type = 
#123 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_type_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1104, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1104, __1), ((Trx_runtime.emptyError) (input_1104))))))) in
(Hashtbl.add (memo_Ocaml_parser_type_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_pattern_aux_aux = 
#127 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_aux_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1166, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1166, 
#129 "ocaml_parser.trx"
( PatVar (Ident.source __1)  )), ((Trx_runtime.emptyError) (input_1166))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1159, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1159)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1160, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1160)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1163, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1163)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1164, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1164, ()), ((Trx_runtime.emptyError) (input_1164)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1160, None), err))
| Trx_runtime.Ok ( ( ( input_1165, r ), err ) ) -> Trx_runtime.Ok(((input_1165, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1161, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1161)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1162, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1162, 
#131 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1162)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_underscore (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1158, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1158, 
#133 "ocaml_parser.trx"
( PatAny  )), ((Trx_runtime.emptyError) (input_1158))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1157, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1157, 
#135 "ocaml_parser.trx"
( PatConst __1  )), ((Trx_runtime.emptyError) (input_1157))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1144, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1144)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1145, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1145)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1146, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1146)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1147, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1152 -> (match (try_Default_semi (_filename) (_text) (input_1152)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1153, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1153)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1154, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1154)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1155, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1155)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1156, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1156, 
#137 "ocaml_parser.trx"
( __2, __4 )), ((Trx_runtime.emptyError) (input_1156)))))))))))))))))) (input_1147)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1148, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_1148)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1148, None), err))
| Trx_runtime.Ok ( ( ( input_1151, r ), err ) ) -> Trx_runtime.Ok(((input_1151, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1149, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_1149)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1150, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1150, 
#138 "ocaml_parser.trx"
( PatRecord ((__2, __4)::__5)
     )), ((Trx_runtime.emptyError) (input_1150))))))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1135, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1135)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1138, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1140 -> (match (try_Default_semi (_filename) (_text) (input_1140)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1141, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1141)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1142, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1142, 
#142 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1142)))))))))))) (input_1138)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1139, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1139, 
#142 "ocaml_parser.trx"
( __1, __2 )), ((Trx_runtime.emptyError) (input_1139)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1135, None), err))
| Trx_runtime.Ok ( ( ( input_1143, r ), err ) ) -> Trx_runtime.Ok(((input_1143, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1136, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1136)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1137, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1137, 
#143 "ocaml_parser.trx"
( match __2 with
       | None -> PatEmptyList
       | Some (a, l) ->
           PatList (a, List.fold_right (fun e accu -> PatList (e, accu)) l PatEmptyList)
     )), ((Trx_runtime.emptyError) (input_1137))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1127, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1127)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1128, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1128)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1129, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1132 -> (match (try_Default_comma (_filename) (_text) (input_1132)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1133, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1133)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1134, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1134, 
#150 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1134)))))))))))) (input_1129)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1130, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1130)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1131, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1131, 
#151 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, __3::__4)
     )), ((Trx_runtime.emptyError) (input_1131))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1124, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1124)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1124, None), err))
| Trx_runtime.Ok ( ( ( input_1126, r ), err ) ) -> Trx_runtime.Ok(((input_1126, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1125, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1125, 
#156 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, match __2 with Some x -> [x] | None -> [])
     )), ((Trx_runtime.emptyError) (input_1125))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1119, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1121 -> (match (try_Ocaml_keywords_AS (_filename) (_text) (input_1121)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1122, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1122)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1123, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1123, 
#159 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1123)))))))))))) (input_1119)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1120, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1120, 
#160 "ocaml_parser.trx"
( List.fold_left (fun accu e -> PatAs (accu, Ident.source e)) __1 __2
   )), ((Trx_runtime.emptyError) (input_1120)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_aux_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_cons = 
#164 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_cons_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1109, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_CONS (_filename) (_text) (input_1109)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1111, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1111)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1112, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1112, 
#164 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1112)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1109, None), err))
| Trx_runtime.Ok ( ( ( input_1113, r ), err ) ) -> Trx_runtime.Ok(((input_1113, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1110, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1110, 
#165 "ocaml_parser.trx"
( match __2 with
     | None -> __1
     | Some x -> PatList (__1, x)
   )), ((Trx_runtime.emptyError) (input_1110)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_cons_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_l = 
#171 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_l_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1114, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_comma (_filename) (_text) (input_1114)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1116, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux_l (_filename) (_text) (input_1116)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1117, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1117, 
#171 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1117)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1114, None), err))
| Trx_runtime.Ok ( ( ( input_1118, r ), err ) ) -> Trx_runtime.Ok(((input_1118, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1115, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1115, 
#172 "ocaml_parser.trx"
( match __2 with
     | None -> [__1]
     | Some s -> __1::s
   )), ((Trx_runtime.emptyError) (input_1115)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_l_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux = 
#178 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_l (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1167, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1167, 
#179 "ocaml_parser.trx"
( match __1 with
     | [t] -> t
     | _ -> PatTuple __1
   )), ((Trx_runtime.emptyError) (input_1167))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_ASSERT = 
#65 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ASSERT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( None )) (input) ("\"assert\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1708, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1708)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1709, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1709, ( () )), ((Trx_runtime.emptyError) (input_1709)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_ASSERT_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_ELSE = 
#73 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ELSE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )) (input) ("\"else\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1696, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1696)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1697, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1697, ( () )), ((Trx_runtime.emptyError) (input_1697)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_ELSE_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_IF = 
#71 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "if")) ) else ( None )) (input) ("\"if\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1682, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1682)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1683, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1683, ( () )), ((Trx_runtime.emptyError) (input_1683)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_IF_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_THEN = 
#72 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_THEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )) (input) ("\"then\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1654, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1654)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1655, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1655, ( () )), ((Trx_runtime.emptyError) (input_1655)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_THEN_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_emptylist = 
#37 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_emptylist_err) (input))
) with
Not_found -> let res = (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1282, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1282)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1283, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1283)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1284, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1284, 
#37 "ocaml_parser.trx"
( EmptyList  )), ((Trx_runtime.emptyError) (input_1284))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_emptylist_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_EmptyList = 
#226 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_EmptyList_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_emptylist (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1580, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1580, __1), ((Trx_runtime.emptyError) (input_1580))))))) in
(Hashtbl.add (memo_Ocaml_parser_EmptyList_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_EXCEPTION = 
#61 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_EXCEPTION_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )) (input) ("\"exception\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1692, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1692)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1693, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1693, ( () )), ((Trx_runtime.emptyError) (input_1693)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_EXCEPTION_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_capMlIdent = 
#117 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1312, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1312)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1313, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1313, 
#117 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1313)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Exception = 
#280 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Exception_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_EXCEPTION (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1574, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input_1574)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1575, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_OF (_filename) (_text) (input_1575)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1577, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1577)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1578, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1578, ()), ((Trx_runtime.emptyError) (input_1578)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1575, None), err))
| Trx_runtime.Ok ( ( ( input_1579, r ), err ) ) -> Trx_runtime.Ok(((input_1579, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1576, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1576, 
#280 "ocaml_parser.trx"
( Exception (__2, None) (* FIXME *) )), ((Trx_runtime.emptyError) (input_1576))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Exception_err) (input) (res)) ; res)
)
let rec try_Default_leftarrow = 
#85 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_leftarrow_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( None )) (input) ("\"<-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1846, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1846)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1847, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1847, ( () )), ((Trx_runtime.emptyError) (input_1847)))))))))) in
(Hashtbl.add (memo_Default_leftarrow_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Const = 
#218 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Const_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1604, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1604, 
#218 "ocaml_parser.trx"
( Const __1  )), ((Trx_runtime.emptyError) (input_1604))))))) in
(Hashtbl.add (memo_Ocaml_parser_Const_err) (input) (res)) ; res)
)
let rec try_Default_dot = 
#78 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_dot_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1876, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1876)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1877, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1877, ( () )), ((Trx_runtime.emptyError) (input_1877)))))))))) in
(Hashtbl.add (memo_Default_dot_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Dot = 
#315 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Dot_err) (input))
) with
Not_found -> let res = (match (try_Default_dot (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1581, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_1590 -> (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1590)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1591, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1591) (_len)) ) then ( let c = ((_get_char) (input_1591)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1591)), c)) ) else ( None ) ) else ( None )) (input_1591) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1592, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1592, 
#315 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1592)))))))))))) (input_1581)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1589, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1589, 
#315 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1589))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1582, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1582)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1588, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1588, 
#315 "ocaml_parser.trx"
( `MlIdent __1 )), ((Trx_runtime.emptyError) (input_1588))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1582)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1584, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_int (_filename) (_text) (input_1584)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1585, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1585)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1586, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1586)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1587, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1587, 
#315 "ocaml_parser.trx"
( `Int __2 )), ((Trx_runtime.emptyError) (input_1587))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1583, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1583, 
#315 "ocaml_parser.trx"
( match __3 with `MlIdent s ->
  let tmp = String.concat_map "." (fun s -> s) __2 in
  let tmp = if tmp = "" then "" else tmp ^ "." in
  `MlIdent (tmp ^ s) | `Int i -> `Int i  )), ((Trx_runtime.emptyError) (input_1583))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Dot_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_BEGIN = 
#58 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_BEGIN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )) (input) ("\"begin\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1706, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1706)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1707, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1707, ( () )), ((Trx_runtime.emptyError) (input_1707)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_BEGIN_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_END = 
#56 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_END_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )) (input) ("\"end\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1694, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1694)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1695, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1695, ( () )), ((Trx_runtime.emptyError) (input_1695)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_END_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_WITH = 
#47 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WITH_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )) (input) ("\"with\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1642, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1642)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1643, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1643, ( () )), ((Trx_runtime.emptyError) (input_1643)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_WITH_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_RNameOpt = 
#257 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_RNameOpt_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1363, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1363)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1364, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1364, 
#257 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1364)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1362, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1362, __1), ((Trx_runtime.emptyError) (input_1362))))))) in
(Hashtbl.add (memo_Ocaml_parser_RNameOpt_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_moduleName_ = 
#119 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName__err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1256, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1256, 
#119 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1256))))))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName__err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_AND = 
#49 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AND_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )) (input) ("\"and\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1714, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1714)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1715, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1715, ( () )), ((Trx_runtime.emptyError) (input_1715)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_AND_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_IN = 
#44 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "in")) ) else ( None )) (input) ("\"in\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1680, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1680)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1681, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1681, ( () )), ((Trx_runtime.emptyError) (input_1681)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_IN_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_LET = 
#42 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_LET_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )) (input) ("\"let\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1678, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1678)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1679, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1679, ( () )), ((Trx_runtime.emptyError) (input_1679)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_LET_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_REC = 
#45 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REC_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )) (input) ("\"rec\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1662, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1662)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1663, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1663, ( () )), ((Trx_runtime.emptyError) (input_1663)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_REC_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_REF = 
#60 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('f'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "ref")) ) else ( None )) (input) ("\"ref\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1660, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1660)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1661, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1661, ( () )), ((Trx_runtime.emptyError) (input_1661)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_REF_err) (input) (res)) ; res)
)
let rec try_Default_bar = 
#80 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_bar_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('|')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'|'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1894, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1894)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1895, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1895, ( () )), ((Trx_runtime.emptyError) (input_1895)))))))))) in
(Hashtbl.add (memo_Default_bar_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_FUNCTION = 
#52 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUNCTION_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( None )) (input) ("\"function\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1686, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1686)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1687, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1687, ( () )), ((Trx_runtime.emptyError) (input_1687)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUNCTION_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MATCH = 
#46 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MATCH_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )) (input) ("\"match\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1676, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1676)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1677, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1677, ( () )), ((Trx_runtime.emptyError) (input_1677)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MATCH_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_WHEN = 
#80 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WHEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )) (input) ("\"when\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1644, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1644)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1645, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1645, ( () )), ((Trx_runtime.emptyError) (input_1645)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_WHEN_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_MODULE = 
#54 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MODULE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( None )) (input) ("\"module\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1674, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1674)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1675, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1675, ( () )), ((Trx_runtime.emptyError) (input_1675)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MODULE_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_STRUCT = 
#55 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_STRUCT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )) (input) ("\"struct\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1656, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1656)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1657, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1657, ( () )), ((Trx_runtime.emptyError) (input_1657)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_STRUCT_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_TYPE = 
#48 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TYPE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )) (input) ("\"type\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1648, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1648)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1649, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1649, ( () )), ((Trx_runtime.emptyError) (input_1649)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_TYPE_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedeflist = 
#57 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeflist_err) (input))
) with
Not_found -> let res = (match (match (try_Default_bar (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1005, r ), err ) ) -> Trx_runtime.Ok(((input_1005, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_999, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_999)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1000, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1002 -> (match (try_Default_bar (_filename) (_text) (input_1002)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1003, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1003)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1004, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1004, 
#57 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1004)))))))))))) (input_1000)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1001, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1001, 
#57 "ocaml_types.trx"
( match __2, __3 with
| _, [] -> __2
| TypeConstructor l1, l2 -> 
	TypeConstructor ( l1 @ List.flatten (List.map (function | TypeConstructor l -> l | _ -> error "@Ocaml_types.typedeflist : must be a constructor") l2))
| _x, _xl -> error "@Ocaml_types.typedeflist : impossible"
 )), ((Trx_runtime.emptyError) (input_1001))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeflist_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typevars = 
#44 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevars_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_961, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_961, 
#44 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_961))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_954, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typevar (_filename) (_text) (input_954)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_955, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_958 -> (match (try_Default_comma (_filename) (_text) (input_958)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_959, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typevar (_filename) (_text) (input_959)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_960, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_960, 
#45 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_960)))))))))))) (input_955)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_956, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_956)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_957, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_957, 
#45 "ocaml_types.trx"
( __2 :: __3  )), ((Trx_runtime.emptyError) (input_957))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevars_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typedeclaration = 
#49 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeclaration_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TYPE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1026, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevars (_filename) (_text) (input_1026)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1026, None), err))
| Trx_runtime.Ok ( ( ( input_1039, r ), err ) ) -> Trx_runtime.Ok(((input_1039, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1027, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1027)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1028, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1028)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1029, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeflist (_filename) (_text) (input_1029)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1030, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1032 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1032)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1033, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevars (_filename) (_text) (input_1033)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1033, None), err))
| Trx_runtime.Ok ( ( ( input_1038, r ), err ) ) -> Trx_runtime.Ok(((input_1038, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1034, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1034)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1035, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1035)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1036, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeflist (_filename) (_text) (input_1036)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1037, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1037, 
#50 "ocaml_types.trx"
( compute_vars __2, __3, __5 )), ((Trx_runtime.emptyError) (input_1037))))))))))))))))))))) (input_1030)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1031, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1031, 
#51 "ocaml_types.trx"
( (compute_vars __2, __3, __5) :: __6  )), ((Trx_runtime.emptyError) (input_1031)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeclaration_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Type = 
#262 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Type_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedeclaration (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1315, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1315, 
#262 "ocaml_parser.trx"
( Type __1  )), ((Trx_runtime.emptyError) (input_1315))))))) in
(Hashtbl.add (memo_Ocaml_parser_Type_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_moduleName = 
#118 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1257, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1257, 
#118 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1257))))))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_OPEN = 
#59 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OPEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )) (input) ("\"open\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1668, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1668)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1669, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1669, ( () )), ((Trx_runtime.emptyError) (input_1669)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_OPEN_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Open = 
#194 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Open_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1381, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1381)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1382, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1382, 
#194 "ocaml_parser.trx"
( Open [ Ident.source __2 ] )), ((Trx_runtime.emptyError) (input_1382)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Open_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_RAISE = 
#63 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_RAISE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "raise")) ) else ( None )) (input) ("\"raise\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1664, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1664)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1665, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1665, ( () )), ((Trx_runtime.emptyError) (input_1665)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_RAISE_err) (input) (res)) ; res)
)
let rec try_Ocaml_keywords_TRY = 
#62 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TRY_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('y'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "try")) ) else ( None )) (input) ("\"try\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1650, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1650)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1651, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1651, ( () )), ((Trx_runtime.emptyError) (input_1651)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_TRY_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FDIV = 
#411 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FDIV_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "/.")) ) else ( None )) (input) ("\"/.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1539, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1539)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1540, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1540, 
#411 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1540)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FDIV_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IDIV = 
#406 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IDIV_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) (true)))) ) then ( Some(((((+)) (input) (1)), "/")) ) else ( None )) (input) ("\"/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1525, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1525)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1526, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1526, 
#406 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1526)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IDIV_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_DIV = 
#401 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_DIV_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FDIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1594, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1594, __1), ((Trx_runtime.emptyError) (input_1594))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IDIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1593, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1593, __1), ((Trx_runtime.emptyError) (input_1593)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_DIV_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_FMULT = 
#410 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMULT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*.")) ) else ( None )) (input) ("\"*.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1535, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1535)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1536, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1536, 
#410 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1536)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FMULT_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_IMULT = 
#405 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMULT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) (true)))) ) then ( Some(((((+)) (input) (1)), "*")) ) else ( None )) (input) ("\"*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1521, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1521)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1522, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1522, 
#405 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1522)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IMULT_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_MULT = 
#400 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MULT_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FMULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1446, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1446, __1), ((Trx_runtime.emptyError) (input_1446))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IMULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1445, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1445, __1), ((Trx_runtime.emptyError) (input_1445)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MULT_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_InfOpLevel4 = 
#375 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel4_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_MULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1499, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1499, __1), ((Trx_runtime.emptyError) (input_1499))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_DIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1498, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1498, __1), ((Trx_runtime.emptyError) (input_1498)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1497, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1497, 
#376 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1497))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel4_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Var = 
#219 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Var_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_paramEffectif (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1314, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1314, 
#219 "ocaml_parser.trx"
( Var __1  )), ((Trx_runtime.emptyError) (input_1314))))))) in
(Hashtbl.add (memo_Ocaml_parser_Var_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Try = 
#287 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Try_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TRY (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1316, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1316)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1317, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1317)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1318, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1318)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1318, None), err))
| Trx_runtime.Ok ( ( ( input_1325, r ), err ) ) -> Trx_runtime.Ok(((input_1325, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1319, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1319)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1320, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1322 -> (match (try_Default_bar (_filename) (_text) (input_1322)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1323, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1323)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1324, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1324, 
#288 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1324)))))))))))) (input_1320)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1321, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1321, 
#288 "ocaml_parser.trx"
( Try (__2 , __5::__6)  )), ((Trx_runtime.emptyError) (input_1321)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Try_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Let = 
#233 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Let_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_LET (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1485, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_keywords_REC (_filename) (_text) (input_1485)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1485, None), err))
| Trx_runtime.Ok ( ( ( input_1491, r ), err ) ) -> Trx_runtime.Ok(((input_1491, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1486, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1486)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1487, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1490 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1490)))) (input_1487)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1488, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1488)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1489, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1489, 
#234 "ocaml_parser.trx"
( __2, __3, __4 )), ((Trx_runtime.emptyError) (input_1489))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1492, r ), err ) ) -> Trx_runtime.Ok(((input_1492, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1475, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1475)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1476, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1478 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1478)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1479, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1479)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1480, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1484 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1484)))) (input_1480)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1481, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1481)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1482, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1482)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1483, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1483, 
#236 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )), ((Trx_runtime.emptyError) (input_1483))))))))))))))))))))) (input_1476)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1477, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1477, 
#238 "ocaml_parser.trx"
( match __1 with
        | None -> __2
        | Some (_rec, name, pfs) ->
                match _rec with
                | Some _ ->
                        let tmp = make_fun __2 pfs in Letrec ((name, tmp)::__3)
                | None -> let tmp = make_fun __2 pfs in Let ((name, tmp)::__3)
         )), ((Trx_runtime.emptyError) (input_1477))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Let_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern = 
#185 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1168, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_WHEN (_filename) (_text) (input_1168)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1170, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1170)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1171, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1171, 
#185 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1171)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1168, None), err))
| Trx_runtime.Ok ( ( ( input_1172, r ), err ) ) -> Trx_runtime.Ok(((input_1172, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1169, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1169, 
#186 "ocaml_parser.trx"
( match __2 with
     | None -> None, __1
     | Some x -> Some x, __1
   )), ((Trx_runtime.emptyError) (input_1169)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Assert = 
#290 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Assert_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_ASSERT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1620, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1620)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1621, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1621, 
#290 "ocaml_parser.trx"
( Assert __2  )), ((Trx_runtime.emptyError) (input_1621)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Assert_err) (input) (res)) ; res)
)
and try_Ocaml_parser_paramFormel = 
#62 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramFormel_err) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1215, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1215)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1216, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1216)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1217, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1217)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1220, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1220)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1221, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1221, 
#63 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1221)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1217, None), err))
| Trx_runtime.Ok ( ( ( input_1222, r ), err ) ) -> Trx_runtime.Ok(((input_1222, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1218, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1218)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1219, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1219, 
#64 "ocaml_parser.trx"
( Label (__3, None, __4)
     )), ((Trx_runtime.emptyError) (input_1219))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1208, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1208)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1209, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1209)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1212, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1212)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1213, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1213, 
#68 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1213)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1209, None), err))
| Trx_runtime.Ok ( ( ( input_1214, r ), err ) ) -> Trx_runtime.Ok(((input_1214, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1210, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1210)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1211, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1211, 
#69 "ocaml_parser.trx"
( Label (__2, __3, None)
     )), ((Trx_runtime.emptyError) (input_1211)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1198, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1198)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1199, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_colon (_filename) (_text) (input_1199)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1200, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1200)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1201, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1201)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1202, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1202)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1205, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1205)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1206, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1206, 
#73 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1206)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1202, None), err))
| Trx_runtime.Ok ( ( ( input_1207, r ), err ) ) -> Trx_runtime.Ok(((input_1207, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1203, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1203)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1204, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1204, 
#74 "ocaml_parser.trx"
( Label (__2, Some __5, __6)
     )), ((Trx_runtime.emptyError) (input_1204))))))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_question (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1186, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1186)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1187, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1187)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1188, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1188)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1195, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1195)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1196, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1196, 
#78 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1196)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1188, None), err))
| Trx_runtime.Ok ( ( ( input_1197, r ), err ) ) -> Trx_runtime.Ok(((input_1197, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1189, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_equal (_filename) (_text) (input_1189)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1192, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1192)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1193, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1193, 
#78 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1193)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1189, None), err))
| Trx_runtime.Ok ( ( ( input_1194, r ), err ) ) -> Trx_runtime.Ok(((input_1194, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1190, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1190)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1191, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1191, 
#79 "ocaml_parser.trx"
( Opt (__3, __4, __5)
      )), ((Trx_runtime.emptyError) (input_1191)))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_question (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1184, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1184)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1185, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1185, 
#83 "ocaml_parser.trx"
( Opt (__2, None, None)  )), ((Trx_runtime.emptyError) (input_1185)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1177, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1177)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1178, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1178)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1181, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1181)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1182, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1182, 
#85 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1182)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1178, None), err))
| Trx_runtime.Ok ( ( ( input_1183, r ), err ) ) -> Trx_runtime.Ok(((input_1183, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1179, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1179)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1180, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1180, 
#86 "ocaml_parser.trx"
( match __3 with
      | None -> Pat (PatVar (Ident.source __2))
      | Some x -> Pat (PatAnnot (PatVar (Ident.source __2), x))
     )), ((Trx_runtime.emptyError) (input_1180)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1176, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1176, 
#93 "ocaml_parser.trx"
( Pat __1
     )), ((Trx_runtime.emptyError) (input_1176)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramFormel_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Abs = 
#229 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Abs_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (true) ((fun input_1633 -> (match (try_Ocaml_keywords_FUN (_filename) (_text) (input_1633)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1634, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1637 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1637)))) (input_1634)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1635, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1635)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1636, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1636, 
#229 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1636))))))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1631, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1631)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1632, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1632, 
#229 "ocaml_parser.trx"
( Abs (List.flatten __1, __2)  )), ((Trx_runtime.emptyError) (input_1632)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Abs_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Module = 
#195 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Module_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_MODULE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1403, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1403)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1404, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1417 -> (match (try_Default_lparen (_filename) (_text) (input_1417)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1418, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1418)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1419, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1419)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1422, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1422)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1423, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1423, 
#196 "ocaml_parser.trx"
( Signature (Referenced [__2])  )), ((Trx_runtime.emptyError) (input_1423)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1419, None), err))
| Trx_runtime.Ok ( ( ( input_1424, r ), err ) ) -> Trx_runtime.Ok(((input_1424, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1420, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1420)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1421, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1421, 
#196 "ocaml_parser.trx"
( __2, __3 )), ((Trx_runtime.emptyError) (input_1421)))))))))))))))))) (input_1404)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1405, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1405)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1414, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1414)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1415, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1415, 
#197 "ocaml_parser.trx"
( Signature (Referenced [__2])  )), ((Trx_runtime.emptyError) (input_1415)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1405, None), err))
| Trx_runtime.Ok ( ( ( input_1416, r ), err ) ) -> Trx_runtime.Ok(((input_1416, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1406, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1406)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1407, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_STRUCT (_filename) (_text) (input_1407)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1410, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1413 -> (try_Ocaml_parser_LetOrType (_filename) (_text) (input_1413)))) (input_1410)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1411, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_END (_filename) (_text) (input_1411)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1412, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1412, 
#198 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1412))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_LetOrType (_filename) (_text) (input_1407)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1409, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1409, 
#198 "ocaml_parser.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_1409)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1408, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1408, 
#198 "ocaml_parser.trx"
( match __3 with [] -> Module (__2, __4, __6, None) | _ -> DeclareFunctor (__2, __3, __4, Structure __6)  )), ((Trx_runtime.emptyError) (input_1408)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Module_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Cons = 
#223 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cons_err) (input))
) with
Not_found -> let res = (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1605, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1605)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1606, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1609 -> (match (try_Default_semi (_filename) (_text) (input_1609)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1610, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1610)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1611, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1611, 
#224 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1611)))))))))))) (input_1606)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1607, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1607)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1608, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1608, 
#225 "ocaml_parser.trx"
( List.fold_right (fun e accu -> Cons (e, accu)) (__2::__3) EmptyList )), ((Trx_runtime.emptyError) (input_1608)))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cons_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Cond = 
#227 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cond_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_IF (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1612, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1612)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1613, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_THEN (_filename) (_text) (input_1613)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1614, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1614)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1615, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_ELSE (_filename) (_text) (input_1615)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1617, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1617)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1618, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1618, 
#227 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1618)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1615, None), err))
| Trx_runtime.Ok ( ( ( input_1619, r ), err ) ) -> Trx_runtime.Ok(((input_1619, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1616, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1616, 
#228 "ocaml_parser.trx"
( Cond (__2, __4, match __5 with None -> Const Unit | Some s -> s)  )), ((Trx_runtime.emptyError) (input_1616))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cond_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Constructor = 
#200 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Constructor_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1600, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1600)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1601, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1601)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1602, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1602)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1603, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1603, 
#202 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __3 with Tuple l -> l | x -> [x])
     )), ((Trx_runtime.emptyError) (input_1603)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1598, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1598)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1599, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1599, 
#207 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, [__2])
     )), ((Trx_runtime.emptyError) (input_1599)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1595, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1595)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1595, None), err))
| Trx_runtime.Ok ( ( ( input_1597, r ), err ) ) -> Trx_runtime.Ok(((input_1597, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1596, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1596, 
#214 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __2 with None -> [] | Some s -> [s])
     )), ((Trx_runtime.emptyError) (input_1596))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Constructor_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Record = 
#258 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Record_err) (input))
) with
Not_found -> let res = (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1340, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_RNameOpt (_filename) (_text) (input_1340)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1340, None), err))
| Trx_runtime.Ok ( ( ( input_1354, r ), err ) ) -> Trx_runtime.Ok(((input_1354, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1341, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1341)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1342, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1342)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1343, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1343)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1344, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1349 -> (match (try_Default_semi (_filename) (_text) (input_1349)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1350, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1350)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1351, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1351)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1352, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1352)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1353, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1353, 
#259 "ocaml_parser.trx"
( __2, __4 )), ((Trx_runtime.emptyError) (input_1353)))))))))))))))))) (input_1344)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1345, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_1345)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1345, None), err))
| Trx_runtime.Ok ( ( ( input_1348, r ), err ) ) -> Trx_runtime.Ok(((input_1348, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1346, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_1346)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1347, __8 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1347, 
#261 "ocaml_parser.trx"
( Record (__2,((__3, __5)::__6))  )), ((Trx_runtime.emptyError) (input_1347)))))))))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Record_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_aux = 
#331 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1541, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_comma (_filename) (_text) (input_1541)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1543, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq_aux (_filename) (_text) (input_1543)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1544, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1544, 
#331 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1544)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1541, None), err))
| Trx_runtime.Ok ( ( ( input_1545, r ), err ) ) -> Trx_runtime.Ok(((input_1545, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1542, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1542, 
#331 "ocaml_parser.trx"
( match __2 with None -> [__1] | Some s -> __1::s  )), ((Trx_runtime.emptyError) (input_1542)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_aux_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Letin = 
#249 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Letin_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_LET (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1449, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_keywords_REC (_filename) (_text) (input_1449)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1449, None), err))
| Trx_runtime.Ok ( ( ( input_1466, r ), err ) ) -> Trx_runtime.Ok(((input_1466, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1450, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1450)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1451, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1465 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1465)))) (input_1451)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1452, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1452)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1453, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1453)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1454, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1458 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1458)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1459, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1459)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1460, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1464 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1464)))) (input_1460)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1461, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1461)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1462, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1462)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1463, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1463, 
#250 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )), ((Trx_runtime.emptyError) (input_1463))))))))))))))))))))) (input_1454)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1455, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_IN (_filename) (_text) (input_1455)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1456, __8 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1456)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1457, __9 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1457, 
#252 "ocaml_parser.trx"
( match __2 with Some _ -> let tmp = make_fun __6 __4 in Letrecin ((__3, tmp)::__7, __9)
        | None -> let tmp = make_fun __6 __4 in Letin ((__3, tmp)::__7, __9)
         )), ((Trx_runtime.emptyError) (input_1457))))))))))))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Letin_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Paren = 
#320 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Paren_err) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1368, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1368)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1369, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1369)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1372, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1372)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1373, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1373, ()), ((Trx_runtime.emptyError) (input_1373)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1369, None), err))
| Trx_runtime.Ok ( ( ( input_1374, r ), err ) ) -> Trx_runtime.Ok(((input_1374, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1370, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1370)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1371, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1371, 
#320 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1371)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_BEGIN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1365, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1365)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1366, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_END (_filename) (_text) (input_1366)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1367, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1367, 
#320 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1367)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Paren_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Raise = 
#282 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Raise_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_RAISE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1355, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input_1355)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1356, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_lparen (_filename) (_text) (input_1356)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1358, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1358)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1359, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1359)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1360, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1360, 
#282 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1360))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1356, None), err))
| Trx_runtime.Ok ( ( ( input_1361, r ), err ) ) -> Trx_runtime.Ok(((input_1361, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1357, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1357, 
#283 "ocaml_parser.trx"
( Raise ([Ident.source __2], __3)
   )), ((Trx_runtime.emptyError) (input_1357))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Raise_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq = 
#332 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1546, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1546, 
#332 "ocaml_parser.trx"
( match __1 with [t] -> t | _ -> Tuple __1  )), ((Trx_runtime.emptyError) (input_1546))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_err) (input) (res)) ; res)
)
and try_Ocaml_parser_SimpleExpr = 
#325 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SimpleExpr_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_dotable (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1330, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1336 -> (try_Ocaml_parser_Dot (_filename) (_text) (input_1336)))) (input_1330)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1331, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_leftarrow (_filename) (_text) (input_1331)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1333, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1333)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1334, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1334, 
#326 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1334)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1331, None), err))
| Trx_runtime.Ok ( ( ( input_1335, r ), err ) ) -> Trx_runtime.Ok(((input_1335, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1332, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1332, 
#326 "ocaml_parser.trx"
( let tmp = List.fold_left (fun accu -> function | `MlIdent e -> Dot (accu, e)
        | `Int i -> Dot (accu, sprintf "(%d)" i)) __1 __2 in match __3  with None -> tmp | Some s -> SetMutable (tmp, s)  )), ((Trx_runtime.emptyError) (input_1332))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1329, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1329, 
#328 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1329))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1326, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_special (_filename) (_text) (input_1326)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1327, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1327)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1328, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1328, 
#329 "ocaml_parser.trx"
( Var (Pated ([Ident.source __2], true))  )), ((Trx_runtime.emptyError) (input_1328)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_SimpleExpr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_App = 
#339 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_App_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_Constructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1630, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1630, __1), ((Trx_runtime.emptyError) (input_1630))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1626, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1626) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1626) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_1626) (1)), "-")) ) else ( None )) (input_1626) ("\"-\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1627 = input_1626 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1627) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1627) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1627) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input_1627) (2)), "::")) ) else ( None )) (input_1627) ("\"::\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1628 = input_1627 in
let __3 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1628) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1628) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1628) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input_1628) (2)), ":=")) ) else ( None )) (input_1628) ("\":=\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1629 = input_1628 in
let __4 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1629, __1), ((Trx_runtime.emptyError) (input_1629))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1623, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1625 -> (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1625)))) (input_1623)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1624, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1624, 
#344 "ocaml_parser.trx"
( match __2 with [] -> __1 | _ -> make_app (__1 :: __2)  )), ((Trx_runtime.emptyError) (input_1624)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1622, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1622, __1), ((Trx_runtime.emptyError) (input_1622)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_App_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Match = 
#263 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Match_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MATCH (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1433, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1433)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1434, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1434)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1435, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1435)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1435, None), err))
| Trx_runtime.Ok ( ( ( input_1442, r ), err ) ) -> Trx_runtime.Ok(((input_1442, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1436, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1436)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1437, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1439 -> (match (try_Default_bar (_filename) (_text) (input_1439)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1440, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1440)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1441, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1441, 
#264 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1441)))))))))))) (input_1437)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1438, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1438, 
#265 "ocaml_parser.trx"
( Match (__2, __5 :: __6)
     )), ((Trx_runtime.emptyError) (input_1438)))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_FUNCTION (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1425, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1425)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1425, None), err))
| Trx_runtime.Ok ( ( ( input_1432, r ), err ) ) -> Trx_runtime.Ok(((input_1432, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1426, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1426)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1427, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1429 -> (match (try_Default_bar (_filename) (_text) (input_1429)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1430, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1430)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1431, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1431, 
#268 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1431)))))))))))) (input_1427)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1428, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1428, 
#269 "ocaml_parser.trx"
( Function (__3::__4)
     )), ((Trx_runtime.emptyError) (input_1428))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Match_err) (input) (res)) ; res)
)
and try_Ocaml_parser_matchExpr = 
#273 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_matchExpr_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1279, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1279)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1280, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1280)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1281, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1281, 
#274 "ocaml_parser.trx"
( match __1 with
     | Some guard, pat -> pat, Some guard, __3
     | None, pat -> pat, None, __3
   )), ((Trx_runtime.emptyError) (input_1281))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_matchExpr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel4 = 
#338 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel4_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_App (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1383, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel4 (_filename) (_text) (input_1383)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1385, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel4 (_filename) (_text) (input_1385)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1386, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1386, 
#338 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1386)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1383, None), err))
| Trx_runtime.Ok ( ( ( input_1387, r ), err ) ) -> Trx_runtime.Ok(((input_1387, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1384, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1384, 
#338 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1384)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel4_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel3 = 
#337 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel3_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel4 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1388, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel3 (_filename) (_text) (input_1388)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1390, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel3 (_filename) (_text) (input_1390)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1391, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1391, 
#337 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1391)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1388, None), err))
| Trx_runtime.Ok ( ( ( input_1392, r ), err ) ) -> Trx_runtime.Ok(((input_1392, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1389, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1389, 
#337 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1389)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel3_err) (input) (res)) ; res)
)
and try_Ocaml_parser_ExprNotApp = 
#292 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_ExprNotApp_err) (input))
) with
Not_found -> let res = (match (match (match (match (try_Ocaml_parser_Open (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1568, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1568, __1), ((Trx_runtime.emptyError) (input_1568))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Module (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1567, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1567, __1), ((Trx_runtime.emptyError) (input_1567))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Cond (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1566, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1566, __1), ((Trx_runtime.emptyError) (input_1566))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Letin (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1565, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1565, __1), ((Trx_runtime.emptyError) (input_1565))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Match (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1564, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1564, __1), ((Trx_runtime.emptyError) (input_1564))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Exception (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1563, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1563, __1), ((Trx_runtime.emptyError) (input_1563))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Raise (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1562, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1562, __1), ((Trx_runtime.emptyError) (input_1562))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Try (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1561, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1561, __1), ((Trx_runtime.emptyError) (input_1561))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Assert (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1560, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1560, __1), ((Trx_runtime.emptyError) (input_1560))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_MakeRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1559, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1559, __1), ((Trx_runtime.emptyError) (input_1559))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_GetRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1558, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1558, __1), ((Trx_runtime.emptyError) (input_1558))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_SetRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1557, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1557, __1), ((Trx_runtime.emptyError) (input_1557))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Cons (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1556, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1556, __1), ((Trx_runtime.emptyError) (input_1556))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_EmptyList (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1555, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1555, __1), ((Trx_runtime.emptyError) (input_1555))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Abs (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1554, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1554, __1), ((Trx_runtime.emptyError) (input_1554))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1553, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1553, __1), ((Trx_runtime.emptyError) (input_1553)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1548, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_CONS (_filename) (_text) (input_1548)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1550, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input_1550)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1551, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1551, 
#311 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1551)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1548, None), err))
| Trx_runtime.Ok ( ( ( input_1552, r ), err ) ) -> Trx_runtime.Ok(((input_1552, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1549, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1549, 
#311 "ocaml_parser.trx"
( match __2 with | None -> __1 | Some x -> Cons (__1, x) )), ((Trx_runtime.emptyError) (input_1549)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1547, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1547, 
#312 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1547))))))) in
(Hashtbl.add (memo_Ocaml_parser_ExprNotApp_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel2 = 
#336 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel2_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel3 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1393, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel2 (_filename) (_text) (input_1393)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1395, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel2 (_filename) (_text) (input_1395)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1396, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1396, 
#336 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1396)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1393, None), err))
| Trx_runtime.Ok ( ( ( input_1397, r ), err ) ) -> Trx_runtime.Ok(((input_1397, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1394, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1394, 
#336 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1394)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel2_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel1 = 
#335 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel1_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel2 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1398, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel1 (_filename) (_text) (input_1398)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1400, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input_1400)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1401, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1401, 
#335 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1401)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1398, None), err))
| Trx_runtime.Ok ( ( ( input_1402, r ), err ) ) -> Trx_runtime.Ok(((input_1402, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1399, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1399, 
#335 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1399)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel1_err) (input) (res)) ; res)
)
and try_Ocaml_parser_paramEffectif = 
#98 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramEffectif_err) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1229, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1229)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1230, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1230)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1233, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1233)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1234, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1234, 
#99 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1234)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1230, None), err))
| Trx_runtime.Ok ( ( ( input_1235, r ), err ) ) -> Trx_runtime.Ok(((input_1235, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1231, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1231)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1232, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1232, 
#100 "ocaml_parser.trx"
( Labeled (__2, __3)
     )), ((Trx_runtime.emptyError) (input_1232)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_1226 -> (match (try_Ocaml_parser_moduleName_ (_filename) (_text) (input_1226)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1227, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1227) (_len)) ) then ( let c = ((_get_char) (input_1227)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1227)), c)) ) else ( None ) ) else ( None )) (input_1227) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1228, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1228, 
#106 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1228)))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1224, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1224)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1225, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1225, 
#107 "ocaml_parser.trx"
( Pated (List.map Ident.source (__1 @ [__2]), false)
     )), ((Trx_runtime.emptyError) (input_1225)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1223, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1223, 
#112 "ocaml_parser.trx"
( Pated (List.map Ident.source __1, true)
     )), ((Trx_runtime.emptyError) (input_1223)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramEffectif_err) (input) (res)) ; res)
)
and try_Ocaml_parser_LetOrType = 
#413 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LetOrType_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1467, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_Type (_filename) (_text) (input_1467)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1474, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1474, __1), ((Trx_runtime.emptyError) (input_1474))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Let (_filename) (_text) (input_1467)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1473, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1473, __1), ((Trx_runtime.emptyError) (input_1473)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1468, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1468) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1468) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1468) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_1468) (2)), ";;")) ) else ( None )) (input_1468) ("\";;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1470, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1470)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1471, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1471, ()), ((Trx_runtime.emptyError) (input_1471)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1468, None), err))
| Trx_runtime.Ok ( ( ( input_1472, r ), err ) ) -> Trx_runtime.Ok(((input_1472, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1469, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1469, 
#413 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1469))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LetOrType_err) (input) (res)) ; res)
)
and try_Ocaml_parser_GetRef = 
#221 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GetRef_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'!'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1527, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1527)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1528, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1528, 
#221 "ocaml_parser.trx"
( GetRef __2  )), ((Trx_runtime.emptyError) (input_1528)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GetRef_err) (input) (res)) ; res)
)
and try_Ocaml_parser_MakeRef = 
#220 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MakeRef_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_REF (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1443, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1443)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1444, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1444, 
#220 "ocaml_parser.trx"
( MakeRef __2 )), ((Trx_runtime.emptyError) (input_1444)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_MakeRef_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr = 
#333 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1569, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_semi (_filename) (_text) (input_1569)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1571, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1571)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1572, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1572, 
#333 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1572)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1569, None), err))
| Trx_runtime.Ok ( ( ( input_1573, r ), err ) ) -> Trx_runtime.Ok(((input_1573, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1570, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1570, 
#333 "ocaml_parser.trx"
( match __2 with None -> __1 | Some x -> Sequence (__1, x)  )), ((Trx_runtime.emptyError) (input_1570)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_dotable = 
#321 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_dotable_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_Record (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1287, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1287, __1), ((Trx_runtime.emptyError) (input_1287))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Paren (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1286, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1286, __1), ((Trx_runtime.emptyError) (input_1286))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Var (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1285, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1285, __1), ((Trx_runtime.emptyError) (input_1285)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_dotable_err) (input) (res)) ; res)
)
and try_Ocaml_parser_SetRef = 
#222 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SetRef_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1337, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_GETREF (_filename) (_text) (input_1337)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1338, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1338)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1339, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1339, 
#222 "ocaml_parser.trx"
( SetRef (__1, __3)  )), ((Trx_runtime.emptyError) (input_1339))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_SetRef_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_lineskipper_noerr = 
#54 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_lineskipper) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_138, __1 ) ) -> (match (try_Ocaml_keywords_TYPE_noerr (_filename) (_text) (input_138)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_139, __2 ) ) -> Some((input_139, ())))) with
None -> let input_132 = input in
let __1 = () in
(match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_135 -> (match if ( (((<)) (input_135) (_len)) ) then ( let c = ((_get_char) (input_135)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_135)), c)) ) else ( None ) ) else ( None ) with
None -> let input_136 = input_135 in
let __1 = () in
if ( (((<)) (input_136) (_len)) ) then ( let c = ((_get_char) (input_136)) in
Some((((succ) (input_136)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_132)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_133, __2 ) ) -> (match if ( (((<)) (input_133) (_len)) ) then ( let c = ((_get_char) (input_133)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_133)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_134, __3 ) ) -> Some((input_134, ( () )))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_types_lineskipper) (input) (res)) ; res)
)
let rec try_Ocaml_types_lineskipper = 
#54 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_lineskipper_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1092, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_TYPE (_filename) (_text) (input_1092)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1093, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1093, ()), ((Trx_runtime.emptyError) (input_1093)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1086 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1089 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1089) (_len)) ) then ( let c = ((_get_char) (input_1089)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_1089)), c)) ) else ( None ) ) else ( None )) (input_1089) (((Trx_runtime.Expected(("'\n'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1090 = input_1089 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1090) (_len)) ) then ( let c = ((_get_char) (input_1090)) in
Some((((succ) (input_1090)), c)) ) else ( None )) (input_1090) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1091, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1091, __2), ((Trx_runtime.emptyError) (input_1091)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_1086)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1087, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1087) (_len)) ) then ( let c = ((_get_char) (input_1087)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_1087)), c)) ) else ( None ) ) else ( None )) (input_1087) (((Trx_runtime.Expected(("'\n'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1088, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1088, ( () )), ((Trx_runtime.emptyError) (input_1088))))))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_types_lineskipper_err) (input) (res)) ; res)
)
let rec try_Default_eof = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None )) (input) (((Trx_runtime.Expected(("any character")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1875 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1875, ()), ((Trx_runtime.emptyError) (input_1875))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))
let rec try_Default_eof_noerr = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None ) with
None -> let input_921 = input in
let __1 = () in
Some((input_921, ()))
| Some ( ( _, _ ) ) -> None))
let rec try_Ocaml_parser_parse_noerr = 
#415 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_parse) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_220, __1 ) ) -> (match (try_Ocaml_parser_parse_noerr (_filename) (_text) (input_220)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_221, __2 ) ) -> Some((input_221, 
#415 "ocaml_parser.trx"
( ((__1 :: __2) : Ocaml.code)  ))))) with
None -> (match (try_Default_eof_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_219, __1 ) ) -> Some((input_219, 
#416 "ocaml_parser.trx"
( []  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_parse) (input) (res)) ; res)
)
let rec try_Ocaml_parser_parse = 
#415 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_parse_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_LetOrType (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1174, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_parse (_filename) (_text) (input_1174)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1175, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1175, 
#415 "ocaml_parser.trx"
( ((__1 :: __2) : Ocaml.code)  )), ((Trx_runtime.emptyError) (input_1175)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_eof (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1173, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1173, 
#416 "ocaml_parser.trx"
( []  )), ((Trx_runtime.emptyError) (input_1173)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_parse_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_test_noerr = 
#52 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_test) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_118, __1 ) ) -> (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input_118)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_119, __2 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_119) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_119) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_119) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_119) (2)), ";;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_120, __3 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_120)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_121, __4 ) ) -> (match (try_Ocaml_types_test_noerr (_filename) (_text) (input_121)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_122, __5 ) ) -> Some((input_122, 
#52 "ocaml_types.trx"
(  )))))))) with
None -> (match (try_Default_eof_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_117, __1 ) ) -> Some((input_117, 
#52 "ocaml_types.trx"
(  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_test) (input) (res)) ; res)
)
let rec try_Ocaml_types_typefinder_noerr = 
#55 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typefinder) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_44 -> (try_Ocaml_types_lineskipper_noerr (_filename) (_text) (input_44)))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_40, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_40)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_41, __2 ) ) -> (match (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input_41)) with
None -> Some((input_41, None))
| Some ( ( input_43, r ) ) -> Some((input_43, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_42, __3 ) ) -> Some((input_42, 
#55 "ocaml_types.trx"
( __3  )))))) in
(Hashtbl.add (memo_Ocaml_types_typefinder) (input) (res)) ; res)
)
let rec try_Ocaml_types_typefinder = 
#55 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typefinder_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_998 -> (try_Ocaml_types_lineskipper (_filename) (_text) (input_998)))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_994, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_994)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_995, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typedeclaration (_filename) (_text) (input_995)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_995, None), err))
| Trx_runtime.Ok ( ( ( input_997, r ), err ) ) -> Trx_runtime.Ok(((input_997, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_996, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_996, 
#55 "ocaml_types.trx"
( __3  )), ((Trx_runtime.emptyError) (input_996))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typefinder_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_test = 
#52 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_test_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1072, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeclaration (_filename) (_text) (input_1072)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1073, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1073) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1073) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1073) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_1073) (2)), ";;")) ) else ( None )) (input_1073) ("\";;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1074, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1074)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1075, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_test (_filename) (_text) (input_1075)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1076, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1076, 
#52 "ocaml_types.trx"
(  )), ((Trx_runtime.emptyError) (input_1076))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_eof (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1071, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1071, 
#52 "ocaml_types.trx"
(  )), ((Trx_runtime.emptyError) (input_1071)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_test_err) (input) (res)) ; res)
)
let parse_ocaml_types_typefinder ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_typefinder_noerr) (_filename))) (((try_Ocaml_types_typefinder) (_filename))) (_text) (_start))
let parse_ocaml_types_typedeclaration ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_typedeclaration_noerr) (_filename))) (((try_Ocaml_types_typedeclaration) (_filename))) (_text) (_start))
let parse_ocaml_types_test ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_test_noerr) (_filename))) (((try_Ocaml_types_test) (_filename))) (_text) (_start))
let parse_ocaml_parser_parse ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_parser_parse_noerr) (_filename))) (((try_Ocaml_parser_parse) (_filename))) (_text) (_start))
