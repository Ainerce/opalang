/*
    Copyright Â© 2011, 2012 MLstate

    This file is part of Opa.

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/////////////////////////////////////////////////////////////////////////////
// NO LONGER SHARED BETWEEN NODE BSL AND JS BSL DUE TO FLOAT_PARSER IMPORT //
/////////////////////////////////////////////////////////////////////////////

##extern-type int32
##extern-type int64

var POW2_32 = 0x0000000100000000; //  2^32
var IMIN32 = -0x0000000100000000; // -2^32
var IMAX32 =  0x00000000ffffffff; //  2^32-1
var POW2_52 = 0x0010000000000000; //  2^52
var IMIN52 = -0x0010000000000000; // -2^52
var IMAX52 =  0x000fffffffffffff; //  2^52-1
var POW2_53 = 0x0020000000000000; //  2^53
var IMIN53 = -0x0020000000000000; // -2^53
var IMAX53 =  0x001fffffffffffff; //  2^53-1
var qNaNstr_be = "\x7f\xc0\x00\x00\x00\x00\x00\x00"; // quiet NaN with no payload
var qNaNstr_le = "\x00\x00\x00\x00\x00\x00\xc0\x7f";
function qNaNstr(le) { return (le) ? qNaNstr_le : qNaNstr_be; }
var qNaNarray_be = [0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]; // quiet NaN with no payload as an array
var qNaNarray_le = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7f];
function qNaNarray(le) { return (le) ? qNaNarray_le : qNaNarray_be; }

##module Int \ bsl_int

// Note: for bitwise ops you only get 32 bits
##register max_int \ max_int: int
var max_int = Math.pow(2, 53);

##register [pure] of_string : string -> int
  ##args(str)
  {
      if (str.length < 2)
          return parseInt(str,10);
      else {
          var hex = /^0x/;
          var is_hex = str.match(hex);
          if (is_hex != null)
              return parseInt(str,16);
          else {
              var oct = /^0o/;
              var is_oct = str.match(oct);
              if (is_oct != null) {
                  return parseInt(str,8);
                }
              else
                  return parseInt(str,10)
          }
      }
  }

##register [pure] of_string_opt : string -> option(int)
    ##args(str)
{
    try {
        js_some(%%BslNumber.Int.of_string%%(str))
    } catch(e) {
        return js_none;
    }
}

##register [pure] of_float : float -> int
  ##args(a)
  {
    if (a<0)
      return Math.ceil(a); // because Math.floor(-3.1) = 4 and not 3
    else
      return Math.floor(a);
  }

// For bitwise you get: floats -> 32-bit ints -> op -> 32-bit ints -> float
// If you try bitwise ops outside of the 32-bit range the results just don't make sense, or are imprecise
// I think it would be safer to just return NaN for values outside this range (or undefined?)

##register [pure] op_land : int, int -> int
##args(n, m)
{
  if (n < IMIN32 || n > IMAX32 || m < IMIN32 || m > IMAX32) return NaN;
  return n & m;
}

##register [pure] op_lor : int, int -> int
##args(n, m)
{
  if (n < IMIN32 || n > IMAX32 || m < IMIN32 || m > IMAX32) return NaN;
  return n | m;
}

##register [pure] op_lxor : int, int -> int
##args(n, m)
{
  if (n < IMIN32 || n > IMAX32 || m < IMIN32 || m > IMAX32) return NaN;
  return n ^ m;
}

##register [pure] op_lnot : int -> int
##args(n)
{
  if (n < IMIN32 || n > IMAX32) return NaN;
  return ~n;
}

##register [pure] op_lsl : int, int -> int
##args(n, m)
//function op_lsl(n,m)
{
  if (m >= 32 || n < IMIN32 || n > IMAX32) return NaN;
  return n << m;
}

##register [pure] op_lsr : int, int -> int
##args(n, m)
//function op_lsr(n,m)
{
  if (m >= 32) return 0;
  if (n < IMIN32 || n > IMAX32) return NaN;
  return n >>> m;
}

##register [pure] op_asr : int, int -> int
##args(n, m)
//function op_asr(n, m)
{
  if (n < IMIN32 || n > IMAX32) return NaN;
  if (m >= 32) return (n & 0x80000000) ? -1 : 0;
  return n >> m;
}

##register [pure] leq:int, int -> bool
##args(c1,c2)
{
   return c1 <= c2
}

##register [pure] geq:int, int -> bool
##args(c1,c2)
{
   return c1 >= c2
}

##register [pure] ordering: int,int -> opa[Order.ordering]
##args(c1,c2)
{
    if(c1<c2) return result_lt
    if(c1==c2) return result_eq
    return result_gt
}

##endmodule

##module Float \ bsl_float

##register [pure] of_int : int -> float
  ##args(a)
  {
    return a;
  }

##register [pure] of_string : string -> float
  ##args(v)
  {
    return parseFloat(v)
  }

##register [pure] of_string_opt : string -> option(float)
    ##args(str)
{
    try {
        js_some(%%BslNumber.Float.of_string%%(str))
    } catch(e) {
        return js_none;
    }
}

  // transforms the string so that it is compatible with the mlbsl
  // (see the comment there)
##register [pure] to_string : float -> string
  ##args(v)
{
    var str = ""+v;
    if (str.indexOf('.') >= 0 || str.indexOf('e') >= 0 || str[0] == 'N' || str[0] == 'I' || str[1] == 'I') {
        return str; //Printing corresponds to server-side printing
    } else {
        return str + ".0";//Printing needs to be adjusted
    }
}

  // should also be compatible with mlbsl
##register [pure] to_formatted_string : bool, option(int), float -> string
  ##args(always_dot,decimals_option,f)
  {
      var str = ""+f;
      if ('none' in decimals_option) {
          if (!always_dot || (str.indexOf('.') >= 0) || str.indexOf('e') >= 0 || str[0] == 'N' || str[0] == 'I' || str[1] == 'I') {
              // either js stringification already doesn't print the dot when not necessary
              // or if there is already one, nothing to do
              // or we have a '1e-88' kind of float and we don't add any point
              // or we have NaN or Infinity or -Infinity, and we can't add a decimal point
              return str;
          } else {
              // we want a dot, and didn't find one in str, so we add it ourselves
              return str + ".0";
          }
      } else {
          if (always_dot || str.indexOf('.') >= 0) {
              // either, we want a dot, we will have it when calling toFixed
              // or we have a real float (there is a dot), keep the dot, but truncate the string
              return f.toFixed(decimals_option.some);
          } else {
              // int or special cases, or scientific notation
              return str;
          }
      }
  }

##register [pure] round    \ `Math.round`   : float -> int
##register [pure] ceil     \ `Math.ceil`    : float -> float
##register [pure] floor    \ `Math.floor`   : float -> float

##register [pure] leq:float, float -> bool
##args(c1,c2)
{
   return c1 <= c2
}

##register [pure] lt:float, float -> bool
##args(c1,c2)
{
   return c1 < c2
}

##register [pure] eq:float, float -> bool
##args(c1,c2)
{
   return c1 == c2
}

##register [pure] geq:float, float -> bool
##args(c1,c2)
{
   return c1 >= c2
}

##register [pure] gt:float, float -> bool
##args(c1,c2)
{
   return c1 > c2
}

##register [pure] neq:float, float -> bool
##args(c1,c2)
{
   return c1 != c2
}

##register [pure] comparison: float,float -> opa[Order.comparison]
##args(c1,c2)
{
    if(isNaN(c1) || isNaN(c2)) return result_neq
    if(c1<c2) return result_lt
    if(c1==c2) return result_eq
    return result_gt
}

function code(i) {
  // Ridiculous, there has to be a better way than this to prevent Javascript from casting ints to strings.
  var tab =
    ["\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07","\x08","\x09","\x0a","\x0b","\x0c","\x0d","\x0e","\x0f",
     "\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17","\x18","\x19","\x1a","\x1b","\x1c","\x1d","\x1e","\x1f",
     "\x20","\x21","\x22","\x23","\x24","\x25","\x26","\x27","\x28","\x29","\x2a","\x2b","\x2c","\x2d","\x2e","\x2f",
     "\x30","\x31","\x32","\x33","\x34","\x35","\x36","\x37","\x38","\x39","\x3a","\x3b","\x3c","\x3d","\x3e","\x3f",
     "\x40","\x41","\x42","\x43","\x44","\x45","\x46","\x47","\x48","\x49","\x4a","\x4b","\x4c","\x4d","\x4e","\x4f",
     "\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57","\x58","\x59","\x5a","\x5b","\x5c","\x5d","\x5e","\x5f",
     "\x60","\x61","\x62","\x63","\x64","\x65","\x66","\x67","\x68","\x69","\x6a","\x6b","\x6c","\x6d","\x6e","\x6f",
     "\x70","\x71","\x72","\x73","\x74","\x75","\x76","\x77","\x78","\x79","\x7a","\x7b","\x7c","\x7d","\x7e","\x7f",
     "\x80","\x81","\x82","\x83","\x84","\x85","\x86","\x87","\x88","\x89","\x8a","\x8b","\x8c","\x8d","\x8e","\x8f",
     "\x90","\x91","\x92","\x93","\x94","\x95","\x96","\x97","\x98","\x99","\x9a","\x9b","\x9c","\x9d","\x9e","\x9f",
     "\xa0","\xa1","\xa2","\xa3","\xa4","\xa5","\xa6","\xa7","\xa8","\xa9","\xaa","\xab","\xac","\xad","\xae","\xaf",
     "\xb0","\xb1","\xb2","\xb3","\xb4","\xb5","\xb6","\xb7","\xb8","\xb9","\xba","\xbb","\xbc","\xbd","\xbe","\xbf",
     "\xc0","\xc1","\xc2","\xc3","\xc4","\xc5","\xc6","\xc7","\xc8","\xc9","\xca","\xcb","\xcc","\xcd","\xce","\xcf",
     "\xd0","\xd1","\xd2","\xd3","\xd4","\xd5","\xd6","\xd7","\xd8","\xd9","\xda","\xdb","\xdc","\xdd","\xde","\xdf",
     "\xe0","\xe1","\xe2","\xe3","\xe4","\xe5","\xe6","\xe7","\xe8","\xe9","\xea","\xeb","\xec","\xed","\xee","\xef",
     "\xf0","\xf1","\xf2","\xf3","\xf4","\xf5","\xf6","\xf7","\xf8","\xf9","\xfa","\xfb","\xfc","\xfd","\xfe","\xff"
     ];
  return tab[i];
}

function uncode(s) {
  // Even more ridiculous
  var tab = {
    '\x00':0x00, '\x01':0x01, '\x02':0x02, '\x03':0x03, '\x04':0x04, '\x05':0x05, '\x06':0x06, '\x07':0x07,
    '\x08':0x08, '\x09':0x09, '\x0a':0x0a, '\x0b':0x0b, '\x0c':0x0c, '\x0d':0x0d, '\x0e':0x0e, '\x0f':0x0f,
    '\x10':0x10, '\x11':0x11, '\x12':0x12, '\x13':0x13, '\x14':0x14, '\x15':0x15, '\x16':0x16, '\x17':0x17,
    '\x18':0x18, '\x19':0x19, '\x1a':0x1a, '\x1b':0x1b, '\x1c':0x1c, '\x1d':0x1d, '\x1e':0x1e, '\x1f':0x1f,
    '\x20':0x20, '\x21':0x21, '\x22':0x22, '\x23':0x23, '\x24':0x24, '\x25':0x25, '\x26':0x26, '\x27':0x27,
    '\x28':0x28, '\x29':0x29, '\x2a':0x2a, '\x2b':0x2b, '\x2c':0x2c, '\x2d':0x2d, '\x2e':0x2e, '\x2f':0x2f,
    '\x30':0x30, '\x31':0x31, '\x32':0x32, '\x33':0x33, '\x34':0x34, '\x35':0x35, '\x36':0x36, '\x37':0x37,
    '\x38':0x38, '\x39':0x39, '\x3a':0x3a, '\x3b':0x3b, '\x3c':0x3c, '\x3d':0x3d, '\x3e':0x3e, '\x3f':0x3f,
    '\x40':0x40, '\x41':0x41, '\x42':0x42, '\x43':0x43, '\x44':0x44, '\x45':0x45, '\x46':0x46, '\x47':0x47,
    '\x48':0x48, '\x49':0x49, '\x4a':0x4a, '\x4b':0x4b, '\x4c':0x4c, '\x4d':0x4d, '\x4e':0x4e, '\x4f':0x4f,
    '\x50':0x50, '\x51':0x51, '\x52':0x52, '\x53':0x53, '\x54':0x54, '\x55':0x55, '\x56':0x56, '\x57':0x57,
    '\x58':0x58, '\x59':0x59, '\x5a':0x5a, '\x5b':0x5b, '\x5c':0x5c, '\x5d':0x5d, '\x5e':0x5e, '\x5f':0x5f,
    '\x60':0x60, '\x61':0x61, '\x62':0x62, '\x63':0x63, '\x64':0x64, '\x65':0x65, '\x66':0x66, '\x67':0x67,
    '\x68':0x68, '\x69':0x69, '\x6a':0x6a, '\x6b':0x6b, '\x6c':0x6c, '\x6d':0x6d, '\x6e':0x6e, '\x6f':0x6f,
    '\x70':0x70, '\x71':0x71, '\x72':0x72, '\x73':0x73, '\x74':0x74, '\x75':0x75, '\x76':0x76, '\x77':0x77,
    '\x78':0x78, '\x79':0x79, '\x7a':0x7a, '\x7b':0x7b, '\x7c':0x7c, '\x7d':0x7d, '\x7e':0x7e, '\x7f':0x7f,
    '\x80':0x80, '\x81':0x81, '\x82':0x82, '\x83':0x83, '\x84':0x84, '\x85':0x85, '\x86':0x86, '\x87':0x87,
    '\x88':0x88, '\x89':0x89, '\x8a':0x8a, '\x8b':0x8b, '\x8c':0x8c, '\x8d':0x8d, '\x8e':0x8e, '\x8f':0x8f,
    '\x90':0x90, '\x91':0x91, '\x92':0x92, '\x93':0x93, '\x94':0x94, '\x95':0x95, '\x96':0x96, '\x97':0x97,
    '\x98':0x98, '\x99':0x99, '\x9a':0x9a, '\x9b':0x9b, '\x9c':0x9c, '\x9d':0x9d, '\x9e':0x9e, '\x9f':0x9f,
    '\xa0':0xa0, '\xa1':0xa1, '\xa2':0xa2, '\xa3':0xa3, '\xa4':0xa4, '\xa5':0xa5, '\xa6':0xa6, '\xa7':0xa7,
    '\xa8':0xa8, '\xa9':0xa9, '\xaa':0xaa, '\xab':0xab, '\xac':0xac, '\xad':0xad, '\xae':0xae, '\xaf':0xaf,
    '\xb0':0xb0, '\xb1':0xb1, '\xb2':0xb2, '\xb3':0xb3, '\xb4':0xb4, '\xb5':0xb5, '\xb6':0xb6, '\xb7':0xb7,
    '\xb8':0xb8, '\xb9':0xb9, '\xba':0xba, '\xbb':0xbb, '\xbc':0xbc, '\xbd':0xbd, '\xbe':0xbe, '\xbf':0xbf,
    '\xc0':0xc0, '\xc1':0xc1, '\xc2':0xc2, '\xc3':0xc3, '\xc4':0xc4, '\xc5':0xc5, '\xc6':0xc6, '\xc7':0xc7,
    '\xc8':0xc8, '\xc9':0xc9, '\xca':0xca, '\xcb':0xcb, '\xcc':0xcc, '\xcd':0xcd, '\xce':0xce, '\xcf':0xcf,
    '\xd0':0xd0, '\xd1':0xd1, '\xd2':0xd2, '\xd3':0xd3, '\xd4':0xd4, '\xd5':0xd5, '\xd6':0xd6, '\xd7':0xd7,
    '\xd8':0xd8, '\xd9':0xd9, '\xda':0xda, '\xdb':0xdb, '\xdc':0xdc, '\xdd':0xdd, '\xde':0xde, '\xdf':0xdf,
    '\xe0':0xe0, '\xe1':0xe1, '\xe2':0xe2, '\xe3':0xe3, '\xe4':0xe4, '\xe5':0xe5, '\xe6':0xe6, '\xe7':0xe7,
    '\xe8':0xe8, '\xe9':0xe9, '\xea':0xea, '\xeb':0xeb, '\xec':0xec, '\xed':0xed, '\xee':0xee, '\xef':0xef,
    '\xf0':0xf0, '\xf1':0xf1, '\xf2':0xf2, '\xf3':0xf3, '\xf4':0xf4, '\xf5':0xf5, '\xf6':0xf6, '\xf7':0xf7,
    '\xf8':0xf8, '\xf9':0xf9, '\xfa':0xfa, '\xfb':0xfb, '\xfc':0xfc, '\xfd':0xfd, '\xfe':0xfe, '\xff':0xff
  };
  return tab[s];
}

function a2s(a) {
  var s = "";
  for (var i = 0; i < a.length; i++) { s += code(a[i]) };
  return s;
}

function s2a(s) {
  var a = new Array(s.length);
  for (var i = 0; i < s.length; i++) { a[i] = uncode(s[i]) };
  return a;
}

function clen(c) {
  if (c >= 0 && c <= 0xff) return 1;
  if (c >= 0 && c <= 0xffff) return 2;
  if (c >= 0 && c <= 0xffffffff) return 4;
  return 8;
}

function slen(s,start,length) {
  var size = 0;
  start = (start === undefined) ? 0 : start;
  end = (length === undefined) ? s.length : (start + length > s.length) ? s.length : start + length;
  for (i = start; i < end; size += clen(s.charCodeAt(i++)));
  return size;
}

// This routine flattens out unicode characters, "\uabcd" -> <Buffer ab cd>
function s2bj(s,start,length,b,j) {
  start = (start === undefined) ? 0 : start;
  end = (length === undefined) ? s.length : (start + length > s.length) ? s.length : start + length;
  for (i = start; i < end; i++) {
    var c = s.charCodeAt(i);
    if (c >= 0 && c <= 0xff) {
      b[j++] = c;
    } else if (c >= 0 && c <= 0xffff) {
      b[j++] = (c >> 8) & 0xff;
      b[j++] =  c       & 0xff;
    } else if (c >= 0 && c <= 0xffffffff) {
      b[j++] = (c >> 24) & 0xff;
      b[j++] = (c >> 16) & 0xff;
      b[j++] = (c >>  8) & 0xff;
      b[j++] =  c        & 0xff;
    } else {
      throw "BslNumber.s2b: bad char code";
    };
  };
  return b;
}

function s2b(s,start,length) {
  var b = new Buffer(slen(s,start,length)), j = 0;
  return s2bj(s,start,length,b,j);
}

##register IMAX \ `IMAX53` : int

function dump(s)
{
  var b = s2b(s)
  var i = 0, d = "";
  while (i < b.length) {
    var h = "", a = "", pos = i.toString(16);
    while (pos.length < 4) { pos = "0" + pos; };
    for (var j = 0; i < b.length && j < 16; i++,j++) {
      var ch = b[i];
      var ac = (ch >= 0x20 && ch < 0x7f) ? code(b[i]) : ".";
      var hx = ch.toString(16);
      if (hx.length == 1) hx = "0" + hx;
      var sp = (i == b.length - 1) ? "" : " ";
      h += hx + sp;
      a += ac;
    };
    while (h.length < 3*16) { h += " "; };
    d += pos + " " + h + " " + a + "\n";
  };
  return d;
}

##register dump : string -> string
##args(s)
{
  dump(s);
}

/* These are integer embedding/unembedding routines which work with the full
 * 53-bit accuracy of the Javascript number format, ie. the mantissa.
 * They have been quite well tested but are probably very slow.
 */

function embed_int_array(le, i)
{
  function aret(le, a) { return (le) ? a.reverse() : a; }
  if (i > IMIN32 && i <= IMAX32) {
    var tm = 0x00, p = i;
    if (i < 0) { tm = 0xff; p = ~(-i) + 1; };
    return aret(le, [tm,tm,tm,tm,(p >>> 24) & 0xff,(p >>> 16) & 0xff,(p >>> 8) & 0xff,p & 0xff]);
  }
  if (i < IMIN53 || i > IMAX53) return qNaNarray(le);
  // -2^(n-1) is a "weird" number, the complement doesn't work
  if (i == IMIN53) return aret(le, [0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00]);
  var negative = i < 0;
  var tm1=0x00, tm2=0x00;
  if (i < 0) i = -i;
  var ph = Math.floor(i / POW2_32);
  var pl = i % POW2_32;
  if (negative) {
    tm1 = 0xff; tm2 = 0xe0;
    pl = ~pl + 1;
    ph = ~ph + ((pl == 0) ? 1 : 0);
    if (ph == 0) { return qNaNarray(le); };
  };
  return aret(le, [tm1 | ((ph >>> 24) & 0xff),tm2 | ((ph >>> 16) & 0xff),(ph >>> 8) & 0xff,ph & 0xff,
                   (pl >>> 24) & 0xff,(pl >>> 16) & 0xff,(pl >>> 8) & 0xff,pl & 0xff]);
}

##register [pure] embed_int_le : int -> string
##args(i)
{
  var a = embed_int_array(true, i);
  return a2s(a);
}

##register [pure] embed_int_be : int -> string
##args(i)
{
  var a = embed_int_array(false, i);
  return a2s(a);
}

##register unembed_int_le: string, int -> int
##args(s, offset)
{
  var b = s2b(s, offset, 8);
  if ((b[7] & 0x80) != 0) {
    if (b[7] != 0xff || (b[6] & 0xfe) != 0xfe) return NaN;
    var iu = 0, il = 0;
    for (var j = 7; j >= 4; j--) { iu = (iu * 0x100) + b[j]; };
    for (var j = 3; j >= 0; j--) { il = (il * 0x100) + b[j]; };
    il--;
    iu = iu - ((il == -1) ? 1 : 0);
    il = ~il;
    if (il < 0) il += POW2_32;
    iu = ~iu;
    return -((iu * 0x100000000) + il);
  } else {
    if (s.substr(offset,8) === qNaNstr_le) return NaN;
    var i = 0;
    for (var j = 7; j >= 0; j--) { i = (i * 0x100) + b[j]; };
    if (i > IMAX53) return NaN;
    return i;
  };
}

##register unembed_int_be: string, int -> int
##args(s, offset)
{
  var b = s2b(s, offset, 8);
  if ((b[0] & 0x80) != 0) {
    if (b[0] != 0xff || (b[1] & 0xfe) != 0xfe) return NaN;
    var iu = 0, il = 0;
    for (var j = 0; j < 4; j++) { iu = (iu * 0x100) + b[j]; };
    for (var j = 4; j < 8; j++) { il = (il * 0x100) + b[j]; };
    il--;
    iu = iu - ((il == -1) ? 1 : 0);
    il = ~il;
    if (il < 0) il += POW2_32;
    iu = ~iu;
    i = -((iu * 0x100000000) + il);
    return i;
  } else {
    if (s.substr(offset,8) === qNaNstr_be) return NaN;
    var i = 0;
    for (var j = 0; j < 8; j++) { i = (i * 0x100) + b[j]; };
    if (i > IMAX53) return NaN;
    return i;
  };
}

/* Same but for 64-bit floating point numbers. */

##register embed_float_le : float -> string
##args(f)
//function embed_float_le(f)
{
  var b = new Buffer(8);
  b.writeDoubleLE(f, 0);
  return a2s(b);
}

##register embed_float_be : float -> string
##args(f)
//function embed_float_be(f)
{
  var b = new Buffer(8);
  b.writeDoubleBE(f, 0);
  return a2s(b);
}

##register unembed_float_le: string, int -> float
##args(s, offset)
{
  return (s2b(s,offset,8)).readDoubleLE(0);
}

##register unembed_float_be: string, int -> float
##args(s, offset)
{
  return (s2b(s,offset,8)).readDoubleBE(0);
}

##register is_int_NaN   \ `isNaN`        : int -> bool

##endmodule

##module Math \ bsl_math

##register [pure] sqrt_i : int -> int
##args(n)
{
    return Math.floor(Math.sqrt(n));
}

##register [pure] log     \ `Math.log`     : float -> float
##register [pure] sqrt_f  \ `Math.sqrt`    : float -> float
##register [pure] exp     \ `Math.exp`     : float -> float

##register [pure] abs_i   \ `Math.abs`     : int -> int
##register [pure] abs_f   \ `Math.abs`     : float -> float

##register [pure] ceil    \ `Math.ceil`    : float -> float
##register [pure] floor   \ `Math.floor`   : float -> float

##register [pure] sin     \ `Math.sin`     : float -> float
##register [pure] cos     \ `Math.cos`     : float -> float
##register [pure] tan     \ `Math.tan`     : float -> float

##register [pure] asin    \ `Math.asin`    : float -> float
##register [pure] acos    \ `Math.acos`    : float -> float
##register [pure] atan    \ `Math.atan`    : float -> float

##register [pure] isNaN   \ `isNaN`        : float -> bool

##register [pure] is_infinite : float -> bool
##args(n)
{
    return !(isFinite(n) || isNaN(n));
}

##register [pure] is_normal \ `isFinite` : float -> bool

##endmodule

##module Random
##register int : int -> int
  ##args(n)
  {
    return Math.floor(Math.random() * n)
  }
##register float : float -> float
  ##args(n)
  {
    return Math.random() * n
  }

##register random_init : -> void
  ##args()
  {
      return ;
  }

function makeStringFromChars(chars, len) {
    var s = "";
    for (var i = 0; i < len; ++i)
	s += chars.charAt(Math.floor(Math.random() * chars.length));
    return s;
}

##register generic_string : string, int -> string
    ##args(chars, len)
{
    return (makeStringFromChars(chars, len));
}

##register string : int -> string
    ##args(len)
{
    var chars = "abcdefghijklmnopqrstuvwxyz";
    return makeStringFromChars(chars, len);
}

##register base64 : int -> string
    ##args(len)
{
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    return makeStringFromChars(chars, len)
  }

##register base64_url : int -> string
    ##args(len)
{
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    return makeStringFromChars(chars, len)
  }

##endmodule
