(* ============== Bypass Standard Library =============== *)
(*                      qml-default                       *)
(* ====================================================== *)

(* New version of qmldefault, based on the libbsl 
   @date lundi 13 avril 2009, 18:39:08 (UTC+0100) *)

(* This code contains default qml-codes (for compiler, or top-level) *)

(* 
   Nicolas : keep going here, and in opa if you preffer, the sources are shared 
   
   use of ##include :
   after instalation of libbsl, see this exemple with bslbrowser :

   shell$ rlwrap bslbrwoser
   bslbrowser -- introspection in Opa / Qml (Bypass) Standard Library
   bslbrowser:/$ ##include "#n, #k, #t" "" int_of_float

   a good guidline for example : 
   - open bslbrowser in a terminal with rlwrap bslbrowser 
   - and edit this file at the same time to preserve meta-syntax error
   - and edit this file at the same time 

   we have here just simples example, so you make your way
*)

(* Here are some exemples of format maybe you will need *)

(* simples rules *)
##format function "val #n = %%#k%% : #t"
##format functions "let #n = %%#k%% : #t in"
##format bind-module "#m = #m"
##format bind "#n = #n" " ; "
(* Let's start *)
##format import-module "let #n = %%#k%% : #t in"
##format in-module "#{import-module}" 
##format sub-module "let #m = \n#{#rec, import-module}\n { #{bind-module bind} } in" 
##format module "val #m = \n#{ sub-module, import-module }\n  { #{bind-module bind} }"
##format pervasives "#{function}"
##format plot_hierarchy "module #m #{#rec}"


BIG BUG TRX : 

    if we do let this header - comment in qml file, the parser cannot parse it !!	(he's taking very much time (exponential loop inside ?))

shame on trx ! (or, I hope, just shame on the inappropriate rule to parse comment ...)

SO, we split the qml-init code into different file (one pro module)

(*
  
TODO : no type and warning with the following : 

type ('a, 'b) map = 
    { empty } / 
    { left : ('a, 'b) map ; key : 'a ; value : 'b ; right : ('a, 'b) map ; height : int64 } 

type 'a stringmap = (string, 'a) map
type 'a int64map = (int64, 'a) map

val make_map compare =
  let empty_map = { empty } : map in
  let singleton key value = { left = empty_map ; key = key ; value = value ; right = empty_map ; height = 1 } : map in
  let height m = match m : map with { empty } -> 0 | { height } -> height in
  let rec size m = 
    match m : map with
      | { empty } -> 0
      | { left ; right } -> 1 + size left + size right
  in
  let create l x d r =
    let hl = height l in
    let hr = height r in
    { left = l 
    ; key = x 
    ; value = d 
    ; right = r 
    ; height = (if hl >= hr then hl + 1 else hr + 1) } : map
  in
  let bal l x d r =
    let hl = height l in
    let hr = height r in
    if hl > (hr + 2) then (
      match l : map with
      | { left ; key ; value ; right } ->
          if height left >= height right then
            create left key value (create right x d r)
          else (
            match right (* : map *) with
            | { left = rleft ; key = rkey ; value = rvalue ; right = rright } ->
                create (create left key value rleft) rkey rvalue (create rright x d r)
          )
    ) else 
      if hr > (hl + 2) then (
	match r : map with
	| { left ; key ; value ; right } ->
            if height right >= height left then
              create (create l x d left) key value right
            else (
              match left (* : map *) with
              | { left = rleft ; key = rkey ; value = rvalue ; right = rright } ->
                  create (create l x d rleft) rkey rvalue (create rright key value right)
            )
      ) else
	{ left = l 
	; key = x 
	; value = d 
	; right = r 
	; height = (if hl >= hr then hl + 1 else hr + 1) } : map
  in
  let rec add x data m = 
    match m : map with
    | { empty } -> singleton x data
    | { left ; key ; value ; right ; height } ->
        let c = compare x key in
        if c = 0 then { left = left ; key = x ; value = data ; right = right ; height = height } : map
        else if c < 0 then bal (add x data left) key value right
        else bal left key value (add x data right)
  in
  let rec find x m =
    match m : map with
    | { empty } -> None
    | { left ; key ; value ; right } ->
        let c = compare x key in
        if c = 0 then { some = value } : option
        else find x (if c < 0 then left else right)
  in
  let rec fold f m acc =
    match m : map with
    | { empty } -> acc
    | { left ; key ; value ; right } ->
	fold f right ((fold f left (f key value acc)))
        (* fold f right (f key value (fold f left acc)) *)
  in
  let rec min_binding m =
    match m : map with
    | { left = { empty } ; key ; value ; right } -> { fst = key ;  snd = value } : pair
    | { left ; key ; value ; right } -> min_binding left
    | { empty } -> error \"map.min_binding: Not Found\"
  in
  let rec remove_min_binding m =
    match m : map with
    | { empty = _ } -> empty_map
    | { left = { empty } ; key ; value ; right } -> right
    | { left ; key ; value ; right } -> bal (remove_min_binding left) key value right
  in 

  (* FIXME: ne marche que si t1 et t2 sont déjà triés *)
  let _merge t1 t2 =
    match t1, t2 with
    | { fst = { empty } ; snd = t } -> t
    | { fst = t ; snd = { empty } } -> t
    | _ ->
	let cpl = min_binding t2 in 
        bal t1 (cpl.fst) cpl.snd (remove_min_binding t2)
  in  
  let rec remove x m = 
    match m : map with
    | { empty = _ } -> empty_map
    | { left ; key ; value ; right } ->
	let c = compare x key in
	if c = 0 then _merge left right
	else if c < 0 then bal (remove x left) key value right
	else bal left key value (remove x right)
  in  
  { empty = empty_map
  ; height = height
  ; size = size
  ; create = create
  ; bal = bal
  ; fold = fold
  ; add x data m = add x data m
  ; find x m = find x m
  ; remove = remove
  }

val map = make_map compare
"
;;
*)
