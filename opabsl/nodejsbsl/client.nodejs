/*
    Copyright Â© 2011 MLstate

    This file is part of OPA.

    OPA is free software: you can redistribute it and/or modify it under the
    terms of the GNU Affero General Public License, version 3, as published by
    the Free Software Foundation.

    OPA is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
    more details.

    You should have received a copy of the GNU Affero General Public License
    along with OPA.  If not, see <http://www.gnu.org/licenses/>.
*/

/* This is exactly the same as the qmlJsImpClientLib.js file except that it
 * exports an outer level class.
 */

var Client = function() {

  /* js_void is shared */
  this.js_void = {};
  this._true = true;
  this._false = false;

  /**
   * @type {!Object}
   */
  this.js_none = {none:this.js_void}

  /**
   * @return(!Object)
   */
  this.js_some = function(x) { return {some:x} }

  this.bool2obj = function(x) {
    // WONT BE IMPLEMENTED or change the name
    return x
  }

  this.unsafe_dot = function(r,f) {
    switch (f) {
      case "true": r = dot_true(r); break
      case "false": r = dot_false(r); break
      case _size: r = undefined; break;
      default: r = r[f];
    }
    if (r === undefined) error("unsafe_dot failed on " + f);
    return r
  }

  this.dot = function(r,f) {
    switch (f) {
      case "true": r = dot_true(r); break
      case "false": r = dot_false(r); break
      case _size: r = undefined; break;
      default: r = r[f];
    }
    if (r === undefined) return js_none
      return {some:r}
  }

  this.udot = function(r,f) {
    switch (f) {
      case "true": return dot_true(r)
      case "false": return dot_false(r)
      case _size: return undefined
      default: return r[f];
    }
  }

  this.fold_record = function(f, record, acc) {
    /* after a few tests:
     * [for in] is a slow of iterating over the properties of an object
     *   (even if you don't sort as is done here)
     * it is actually faster if you have the array of fields
     * (in addition to the record you want to fold)
     */
    switch (record) {
      case true: return f("true",this.js_void,acc)
      case false: return f("false",this.js_void,acc)
      default:
      var tab = new Array(), field, i = 0, n;
      for (field in record) _size === field || tab.push(field)
        tab.sort()
        for (n = tab.length; i < n; i++) {
          field = tab[i]
          acc = f(field, record[field], acc)
        }
      return acc
    }
  }

  this.fold_2_record = function(f, record1, record2, acc) {
    switch (record1) {
      case true: return f("true", this.js_void, this.js_void, acc)
      case false: return f("false", this.js_void, this.js_void, acc)
      default:
      var tab = new Array(), field, i = 0, n;
      for (field in record1) _size === field || tab.push(field)
        tab.sort()
        for (n = tab.length; i < n; i++) {
          field = tab[i]
          acc = f(field, record1[field], record2[field], acc)
        }
      return acc
    }
  }

  this.name_of_field = function(field) {
    return {some : field}
  }

  this.field_of_name = function(name) {
    return {some : name}
  }

  this.static_field_of_name = function(name) {
    return name
  }

  this.empty_constructor = function() {
    var c = {} /* this object will be modified, do not share it with this.js_void */
    c[_size] = 0
    return c
  }

  this.add_field = function(constructor, field, value) {
    if (field in constructor) error("add_field: trying to add the field " +field+" to the constructor "+constructor.toSource())
      constructor[field] = value;
    constructor[_size]++;
    return constructor
  }

  this.make_record = function(constructor) {
    switch (size(constructor)) {
      case 0: return this.js_void;
      case 1: return un_uniformize_bool(constructor)
      default: return constructor;
    }
  }

  this.make_simple_record = function(field) {
    switch (field) {
      case "true": return true
      case "false": return false
      default:
      var r = {}
      r[field] = this.js_void
      return r
    }
  }

  this.make_onefield_record = function(field,value) {
    switch (field) {
      case "true": return build_true(value)
      case "false": return build_false(value)
      default:
      var r = {}
      r[field] = value;
      return r;
    }
  }

  this.obj2bool = function() {
    // WONT BE IMPLEMENTED or change the name
    error("obj2bool not implemented")
  }

  this.normalize_obj = function(x) { return x;
                                     // WONT BE IMPLEMENTED
                                     // error("normalize_obj not implemented")
  }

  this.normalize_num = function() {
    // WONT BE IMPLEMENTED or change the name
    error("normalize_num not implemented")
  }

  // FIXME: BUGGY, does not handle special opa fields...
  this.record2obj = function(x) { return x; }

  this.extendrecord = function() {
    // WONT BE IMPLEMENTED or change the name
    error("extendrecord not implemented")
  }

  this.list2js = function(opalist) {
    var result = [], tl;
    while ((tl = opalist.tl) !== undefined) {
      result.push(opalist.hd);
      opalist = tl;
    }
    return result;
  }

  this.js2list = function(array) {
    var i = array.length - 1, result = {nil : this.js_void}
    for (; i >= 0; i--) {
      result = {hd:array[i], tl:result}
    }
    return result
  }

  this.option2js = function(obj) {
    return 'some' in obj ? obj.some : null
  }

  this.option2jsu = function(obj) {
    return obj.some
  }

  this.js2option = function(obj) {
    return obj == null ? js_none : {some : obj}
  }

  this.compare_raw = function(a,b) {
    switch (typeof a){
      case "number":
      case "string":
      case "boolean":
      return a > b ? 1 : a < b ? -1 : 0;
      case "object":
      if (size(a) < size(b)) return -1
        if (size(a) > size(b)) return 1

          var all_fields = {};//The set of fields appearing in [a] and [b]
      var field_name;
      // since size was called on a and b, _size is defined for both records
      // so the comparison cannot fail because _size is defined only on one record
      for(field_name in a) all_fields[field_name] = 0;
      for(field_name in b) all_fields[field_name] = 0;

      var sorted_fields = [];//The set of fields appearing in [a] and [b], sorted in consistent order
      for(field_name in all_fields) sorted_fields.push(field_name);

      //Now compare recursively
      var sorted_fields_length;
      var sorted_fields_index;
      for(sorted_fields_index = 0,
            sorted_fields_length = sorted_fields.length;
          sorted_fields_index < sorted_fields_length;
          sorted_fields_index++)
        {
          field_name  = sorted_fields[sorted_fields_index];
          var field_a = a[field_name];
          var field_b = b[field_name];
          if(field_a === undefined) return -1;
          if(field_b === undefined) return  1;
          var sorting = compare_raw(field_a, field_b);
          if(sorting != 0) return sorting;
        }

      return 0;
      default :
      error("[compare_raw] Cannot compare objects "+a+" and "+b);
    }

    error("compare_raw not implemented")
  }

  this.tailcall_manager_call = function(fun, arg) {
    return fun.call(null, arg) ;
  }

  this.tailcall_manager_apply = function(fun, args) {
    return fun.apply(null, args) ;
  }

  /* call to these functions are generated by the back end */
  this.build_true = function(e) {
    return e === this.js_void ? true : {'true':e}
  }

  this.build_false = function(e) {
    return e === this.js_void ? false : {'false':e}
  }

  this.dot_true = function(e) {
    return e === true ? this.js_void : e["true"]
  }

  this.dot_false = function(e) {
    return e === false ? this.js_void : e["false"]
  }

  // we don't use _size but instead we use size`
  // because in opa, we cannot write field names containing
  // backquotes, so we cannot have collision between size` and
  // user defined fields
  this._size = "size`"
  this.size = function(x) {
    if (x === true || x === false) return 1;
    var i, s ;
    if (s = x[this._size], s != undefined) return s;
    s = 0;
    for (i in x) s++;
    x[this._size] = s;
    return(s)
  }

  // returns {true:this.js_void} or {false:this.js_void} instead of js booleans
  // or else returns the given object
  this.uniformize_bool = function(o) {
    return o === true ? {'true':this.js_void} : o === false ? {'false':this.js_void} : o;
  }

  this.un_uniformize_bool = function(o) {
    return o["true"] === this.js_void && this.size(o) === 1 ? true : o["false"] === this.js_void && this.size(o) === 1 ? false : o;
  }

  this.extend_record = function(original_record,new_fields) {
    original_record = uniformize_bool(original_record)
    for (var i in original_record) {
      // beware: we must not copy the _size field!
      i === _size || i in new_fields || (new_fields[i] = original_record[i])
    }
    return un_uniformize_bool(new_fields)
  }

  /*
   * dynamic type checking
   * the functions in here take (at least) a value
   * and checks that it has the expected type (it is a shallow test
   * since you can't do much better for functions)
   */
  this.typeerror = function(key,msg) {
    error("TypeError on the bsl key %"+"%"+key+"%"+"% : "+msg)
  }

  this.type_var = function(key,value) {
    value != null || typeerror(key,"type var vs value "+value)
  }

  this.type_bool = function(key,value) {
    typeof value == "boolean" || typeerror(key,"type bool vs value "+value)
  }

  this.type_void = function(key,value) {
    value === this.js_void || typeerror(key,"type void vs value "+value)
  }

  this.type_option = function(key,value) {
    size(value) == 1 && ('none' in value || 'some' in value) || typeerror(key,"type option vs value "+value)
  }

  // special case: we accept the this.js_void, in case of a double projection
  this.type_native_void = function(key,value) {
    value == null || value === this.js_void || typeerror(key, "type native void vs value "+value)
  }

  this.type_native_option = function(key,value) {
    value != null || value === null || typeerror(key, "type native option vs value "+value)
  }

  this.type_int = function(key,value) {
    typeof value == "number" && Math.round(value) == value && !isNaN(value) || typeerror(key,"type int vs value "+value)
  }

  this.type_float = function(key,value) {
    typeof value == "number" || typeerror(key,"type float vs value "+value)
  }

  this.type_string = function(key,value) {
    typeof value == "string" || typeerror(key,"type string vs value "+value)
  }

  this.type_char = function(key,value) {
    typeof value == "string" && value.length == 1 || typeerror(key,"type char vs value "+value)
  }

  this.type_extern = function(key,value) {
    value != null || typeerror(key,"type extern vs value "+value)
  }

  this.type_fun = function(key,value) {
    typeof value == "function" || typeerror(key,"type fun vs value "+value)
  }

  this.type_fun_arity = function(key,args,arity) {
    args.length == arity || typeerror(key,"type fun of arity="+arity+" vs arguments received: "+args.length)
  }

  this.type_opavalue = function(key,value) {
    value != null || typeerror(key,"type opavalue vs value "+value)
  }

  /*
   * other dynamic check
   */
  this.assert_length = function(args) {
    var n = args.length;
    while (--n >= 0) {
      args[n] === undefined && error("arity error, "+n+"th argument is undefined")
        }
  }

  /*
   * stuff for dynamic pattern matching
   */
  this.fields_indexes = function(fs) {
    return fs;
  }

  this.field_index = function(fi,f) {
    return f;
  }

  this.dot_with_field_index = function(r,fi) {
    return  unsafe_dot(r,fi);
  }

  this.patterns_indexes = function(patterns) {
    return patterns;
  }

  this.compare_structure_same = function(fields,r) {
    for (var i=0;i<fields.length;i++){
      var field = fields[i];
      if (udot(r,field)==undefined) return false;
    };
    return true;
  }

  this.compare_structure = function(patterns,r1,r2) {
    // TODO in case r1 and r2 has same structure reduce calls remove one compare_structure_same per loop, see serverLib.ml
    for(var ifs=0;ifs<patterns.length;ifs++){
      var fields = patterns[ifs];
      if( compare_structure_same(fields,r1) ){
        if( compare_structure_same(fields,r2) ) return ifs;
        else return -1; /* gt */
      };
      if( compare_structure_same(fields,r2) ) return -2; /* lt */
    };
    return error("compare_structure"+patterns+"\n"+r1);
  }

}

exports.Client = Client;


