
var http = require('http');
var client = require('../../qmljsimp/qmlJsImpClientLib.js');

##extern-type WebInfo.private.native
##extern-type WebInfo.private.native_http_header
##extern-type WebInfo.private.native_request
##extern-type WebInfo.private.native_connection
##extern-type WebInfo.private.native_response
##extern-type web_server_status
##extern-type SSL.secure_type
##extern-type HttpRequest.msg_list
##extern-type list('a)
//'

##module ConvertHeader

function merge_headers(headers) {
  var hdr = { };
  headers.forEach(function (h) { for (var f in h) { hdr[f] = h[f]; } });
  return hdr
}

##register set_cookie : string -> WebInfo.private.native_http_header
##args(value)
{
  return { 'Set-Cookie': value }
}

##register last_modified : time_t -> WebInfo.private.native_http_header
##args(date)
{
  var now = new Date(date)
  return { 'Last-Modified': now }
}

##register cache_control: string -> WebInfo.private.native_http_header
##args(value)
{
  return { 'Cache-Control': value }
}

##register pragma : string -> WebInfo.private.native_http_header
##args(value)
{
  return { 'Pragma': value }
}

##register location : string -> WebInfo.private.native_http_header
##args(value)
{
  return { 'Location': value }
}

##register cdisp_attachment : string -> WebInfo.private.native_http_header
##args(value)
{
  return { 'Content-Disposition': "attachment; filename="+value+";" }
}

##register expires_at : option(time_t) -> WebInfo.private.native_http_header
##args(t)
{
  var exp_time = new Date();
  if ('some' in t) {
    exp_time.setTime(exp_time.getTime()+t.some);
  } else {
    exp_time.setFullYear(exp_time.getFullYear()+1);
  };
  return { 'Expires': exp_time }
}

##endmodule

##module Http_server

##register web_info_request : WebInfo.private.native -> WebInfo.private.native_request
##args(req)
{
  // We'll just leave it intact, it doesn't have any internal "request" field,
  // the whole thing is the request.
  // We also have to do it this way to ensure that the extra parameters are in the
  // native_request rather than in the native.
  return req
}

##register web_info_cont : WebInfo.private.native -> (WebInfo.private.native_response -> void)
##args(req)
{
  // We may need to add extra fields in the Opa handling
  return function (resp) { return js_void }
}

##register web_info_conn : WebInfo.private.native -> WebInfo.private.native_connection
##args(req)
{
  // The connection is actually in the request
  return req.request.connection
}

##register web_info_reconstruct : \
  (WebInfo.private.native_response -> void), \
  WebInfo.private.native_request, \
  WebInfo.private.native_connection -> \
  WebInfo.private.native
##args(f, r, c)
{
  //let web_info_reconstruct f r c = {
  //  HttpServerTypes.cont        = f; -- not present
  //  HttpServerTypes.request     = r; -- the whole request object
  //  HttpServerTypes.connection  = c; -- ignore this, it's in the request
  //  HttpServerTypes.certificate = None; -- use request.connection.getPeerCertificate etc.
  //}
  return r
}

function get_user_agent(req) {
  if ('user-agent' in req.request.headers)
    return req.request.headers['user-agent']
  else if ('User-Agent' in req.request.headers)
    return req.request.headers['User-Agent']
  else
    return "unknown"
}

##register get_user_agent : WebInfo.private.native_request -> string
##args(req)
{
  return get_user_agent(req)
}

##register is_apple_mobile_webapp : WebInfo.private.native_request -> bool
##args(req)
{
  var ua = get_user_agent(req);
  return ua.indexOf("Mobile",0) != -1 && ua.indexOf("Apple",0) != -1 && ua.indexOf("Safari",0) == -1 
}

##register is_apple_mobile : WebInfo.private.native_request -> bool
##args(req)
{
  var ua = get_user_agent(req);
  return ua.indexOf("Mobile",0) != -1 && ua.indexOf("Apple",0) != -1
}

// Not present, will need to be injected into prototype when createServer is called
##register get_server_url : WebInfo.private.native_request -> string
##args(req)
{
  return req.server_url
}

##register get_uri : WebInfo.private.native_request -> string
##args(req)
{
  return req.request.url
}

##register get_method : WebInfo.private.native_request -> string
##args(req)
{
  return req.request.method
}

##register is_secured : WebInfo.private.native_request -> bool
##args(req)
{
  // just guesswork
  var cert = req.request.connection.getPeerCertificate()
  return cert !== null && cert !== undefined
}

##register get_header_names: WebInfo.private.native_request -> opa[list(string)]
##args(req)
{
  var lst = [];
  for (var fld in req.request.headers) { lst.push(fld) };
  return js2list(lst)
}

function gethdr(request, s) {
  return (s in request.headers) ? {some:request.headers[s]} : client.js_none
}

##register get_header_values : WebInfo.private.native_request -> (string -> option(string))
##args(req)
{
  return function (s) { return gethdr(req.request, s) }
}

##register ip_of_web_info : WebInfo.private.native_connection -> string
##args(c)
{
  return c.remoteAddress
}

##register check_connection : WebInfo.private.native_connection -> bool
##args(c)
{
  // Just have to assume open
  return true
}

// BslNet.Http_server.make_response 

function Option_map(f, opt) {
  if (opt === null || opt === undefined) {
    return opt
  } else if ('some' in opt) {
    return {some:f(opt.some)}
  } else {
    return opt
  }
}

function Option_is_some(x) {
  if (x === null || x === undefined) {
    return false
  } else if ('some' in x) {
    return true
  } else {
    return false
  }
}

function Option_is_none(x) {
  if (x === null || x === undefined) {
    return true
  } else if ('some' in x) {
    return false
  } else {
    return true
  }
}

function Option_get(x) {
  if (x === null || x === undefined) {
    return undefined
  } else if ('some' in x) {
    return x.some
  } else {
    return undefined
  }
}

function Option_default(dflt, x) {
  if (x === null || x === undefined) {
    return dflt
  } else if ('some' in x) {
    return x.some
  } else {
    return dflt
  }
}

function is_valid(request, modified_since) {
  if (request.headers['cache-control'] === 'no-cache')
    return false
  else if (request.headers['pragma'] === 'no-cache')
    return false
  else if ('if-modified-since' in request.headers) {
    if (Option_is_some(modified_since)) {
      var mtimein = new Date(request.headers['if-modified-since']);
      return mtimein >= modified_since.some
    } else false
  } else if ('if-unmodified-since' in request.headers) {
    if (Option_is_some(modified_since)) {
      var mtimein = new Date(request.headers['if-unmodified-since']);
      return mtimein < modified_since.some
    } else false
  } else false
}

function process_content(req, expires, modified_since, _type, content, include_body) {
  var now = new Date();
  var content_len = Buffer.byteLength(content.toString(),'utf8');
  var cs;
  if (_type.indexOf("charset") != -1) { cs = "" } else { cs = "; charset=utf-8" };
  var typeval = _type + cs;
  var expires = Option_default(new Date(), expires);
  req.response.setHeader('Date',now);
  req.response.setHeader('Server',req.server_name);
  req.response.setHeader('Content-Type',typeval);
  req.response.setHeader('Expires',expires);
  if (Option_is_some(modified_since)) {
    req.response.setHeader('Cache-Control',"public");
    req.response.setHeader('Last-Modified',modified_since.some);
  };
  req.response.setHeader('Content-Length',content_len);
  if (include_body)
    req.response.end(content)
  else
    req.response.end();
}

function make_response_with_headers(expires,modified_since,req,headers_out,status_line,_type,content,cont) {
  var code = BslNet_Requestdef_status_code(status_line);
  var reason = BslNet_Requestdef_reason_phrase(code);
  var include_body = req.request.method !== 'HEAD';
  console.log("make_response: _type="+_type);
  if (is_valid(req.request, modified_since)) {
    console.log("make_response: code="+304);
    req.response.writeHead(304, {'Date': new Date()});
    req.response.end('Not Modified');
  } else {
    console.log("make_response: code="+code);
    req.response.statusCode = code;
    headers_out.forEach(function (hdr) { for (var h in hdr) { req.response.setHeader(h,hdr[h]) } });
    process_content(req, expires, modified_since, _type, content, include_body)
  };
  cont(req)
}

##register [cps-bypass] make_response : \
    option(time_t), \
    WebInfo.private.native_request, \
    web_server_status, \
    list(WebInfo.private.native_http_header), \
    string, \
    string, \
    continuation(WebInfo.private.native_response) -> void
##args(ms,req,stat,headers,_type,content,k)
{
  var modified_since = Option_map(function (ms) { return new Date(ms) },ms);
  make_response_with_headers(client.js_none, modified_since, req, headers, stat, _type, content, k);
  return js_void
}

##register [cps-bypass] make_response_modified_since : \
    option(time_t), \
    WebInfo.private.native_request, \
    web_server_status, \
    string, \
    string, \
    continuation(WebInfo.private.native_response) -> void
##args(modified_since,req,stat,_type,content,k)
{
  var expires = {some:new Date(0)};
  var modified_since = Option_map(function (ms) { return new Date(ms) },ms);
  make_response_with_headers(expires, modified_since, req, [], stat, _type, content, k);
  return js_void
}

##register [cps-bypass] make_response_expires_at : \
    option(time_t), \
    option(time_t), \
    WebInfo.private.native_request, \
    web_server_status, \
    string, \
    string, \
    continuation(WebInfo.private.native_response) -> void
##args(expires_at,modified_since,req,stat,_type,content,k)
{
  var date = new Date();
  var expires = (Option_is_some(expires_at)) ? date.setTime(expires_at.some) : date.setFullYear(date.getFullYear()+1);
  var modified_since = Option_map(function (ms) { return new Date(ms) },modified_since);
  make_response_with_headers(expires, modified_since, req, [], stat, _type, content, k);
  return js_void
}

function cookies_in(req) {
  req.request.headers.cookie && req.request.headers.cookie.split(';').forEach(function(cookie) {
    var parts = cookie.split('=');
    console.log("cookie: "+cookie);
    req.cookies[parts[0].trim()] = (parts[1] || '').trim();
  });
  return req
}

##register init_server : \
    string, \
    int, \
    option(string), \
    option(string), \
    option(string), \
    SSL.secure_type, \
    (WebInfo.private.native -> void), \
    (string, HttpRequest.msg_list, int -> bool) ->\
    void
##args(name,port,certfileo,privkeyo,passwdo,secure_type,dispatcher,ontransfer)
{
  http.createServer(function (request, response) {
                      var req = cookies_in({server_name:name, cookies:{}, request:request, response:response});
                      console.log(req);
                      return dispatcher(req)
                    }).listen(port);
  return js_void
}

##endmodule

exports.make_response = BslNet_Http_server_make_response
exports.init_server = BslNet_Http_server_init_server

##module Requestdef

// 1xx
##register sc_Continue \ `"SC_Continue"` : web_server_status
##register sc_SwitchingProtocols \ `"SC_SwitchingProtocols"` : web_server_status

// 2xx
##register sc_OK \ `"SC_OK"` : web_server_status
##register sc_Created \ `"SC_Created"` : web_server_status
##register sc_Accepted \ `"SC_Accepted"` : web_server_status
##register sc_Non_AuthoritativeInformation \ `"SC_Non_AuthoritativeInformation"` : web_server_status
##register sc_NoContent \ `"SC_NoContent"` : web_server_status
##register sc_ResetContent \ `"SC_ResetContent"` : web_server_status
##register sc_PartialContent \ `"SC_PartialContent"` : web_server_status

// 3xx
##register sc_MultipleChoices \ `"SC_MultipleChoices"` : web_server_status
##register sc_MovedPermanently \ `"SC_MovedPermanently"` : web_server_status
##register sc_Found \ `"SC_Found"` : web_server_status
##register sc_SeeOther \ `"SC_SeeOther"` : web_server_status
##register sc_NotModified \ `"SC_NotModified"` : web_server_status
##register sc_UseProxy \ `"SC_UseProxy"` : web_server_status
##register sc_TemporaryRedirect \ `"SC_TemporaryRedirect"` : web_server_status

// 4xx
##register sc_BadRequest \ `"SC_BadRequest"` : web_server_status
##register sc_Unauthorized \ `"SC_Unauthorized"` : web_server_status
##register sc_PaymentRequired \ `"SC_PaymentRequired"` : web_server_status
##register sc_Forbidden \ `"SC_Forbidden"` : web_server_status
##register sc_NotFound \ `"SC_NotFound"` : web_server_status
##register sc_MethodNotAllowed \ `"SC_MethodNotAllowed"` : web_server_status
##register sc_NotAcceptable \ `"SC_NotAcceptable"` : web_server_status
##register sc_ProxyAuthenticationRequired \ `"SC_ProxyAuthenticationRequired"` : web_server_status
##register sc_RequestTime_out \ `"SC_RequestTime_out"` : web_server_status
##register sc_Conflict \ `"SC_Conflict"` : web_server_status
##register sc_Gone \ `"SC_Gone"` : web_server_status
##register sc_LengthRequired \ `"SC_LengthRequired"` : web_server_status
##register sc_PreconditionFailed \ `"SC_PreconditionFailed"` : web_server_status
##register sc_RequestEntityTooLarge \ `"SC_RequestEntityTooLarge"` : web_server_status
##register sc_Request_URITooLarge \ `"SC_Request_URITooLarge"` : web_server_status
##register sc_UnsupportedMediaType \ `"SC_UnsupportedMediaType"` : web_server_status
##register sc_RequestedRangeNotSatisfiable \ `"SC_RequestedRangeNotSatisfiable"` : web_server_status
##register sc_ExpectationFailed \ `"SC_ExpectationFailed"` : web_server_status

// 5xx
##register sc_InternalServerError \ `"SC_InternalServerError"` : web_server_status
##register sc_NotImplemented \ `"SC_NotImplemented"` : web_server_status
##register sc_BadGateway \ `"SC_BadGateway"` : web_server_status
##register sc_ServiceUnavailable \ `"SC_ServiceUnavailable"` : web_server_status
##register sc_GatewayTime_out \ `"SC_GatewayTime_out"` : web_server_status
##register sc_HTTPVersionNotSupported \ `"SC_HTTPVersionNotSupported"` : web_server_status

var status_code_map = {
  'SC_Continue':100,
  'SC_SwitchingProtocols':101,
  'SC_OK':200,
  'SC_Created':201,
  'SC_Accepted':202,
  'SC_Non_AuthoritativeInformation':203,
  'SC_NoContent':204,
  'SC_ResetContent':205,
  'SC_PartialContent':206,
  'SC_MultipleChoices':300,
  'SC_MovedPermanently':301,
  'SC_Found':302,
  'SC_SeeOther':303,
  'SC_NotModified':304,
  'SC_UseProxy':305,
  'SC_TemporaryRedirect':307,
  'SC_BadRequest':400,
  'SC_Unauthorized':401,
  'SC_PaymentRequired':402,
  'SC_Forbidden _':403,
  'SC_NotFound':404,
  'SC_MethodNotAllowed':405,
  'SC_NotAcceptable':406,
  'SC_ProxyAuthenticationRequired':407,
  'SC_RequestTime_out':408,
  'SC_Conflict':409,
  'SC_Gone':410,
  'SC_LengthRequired':411,
  'SC_PreconditionFailed':412,
  'SC_RequestEntityTooLarge':413,
  'SC_Request_URITooLarge':414,
  'SC_UnsupportedMediaType':415,
  'SC_RequestedRangeNotSatisfiable':416,
  'SC_ExpectationFailed':417,
  'SC_InternalServerError':500,
  'SC_NotImplemented':501,
  'SC_BadGateway':502,
  'SC_ServiceUnavailable':503,
  'SC_GatewayTime_out':504,
  'SC_HTTPVersionNotSupported':505
};

##register status_code : web_server_status -> int
##args(code)
{
  return (code in status_code_map) ? status_code_map[code] : -1;
}

var reason_phrase_map = {
  100:"Continue",
  101:"Switching Protocols",
  200:"OK",
  201:"Created",
  202:"Accepted",
  203:"Non-Authoritative Information",
  204:"No Content",
  205:"Reset Content",
  206:"Partial Content",
  300:"Multiple Choices",
  301:"Moved Permanently",
  302:"Found",
  303:"See Other",
  304:"Not Modified",
  305:"Use Proxy",
  307:"Temporary Redirect",
  400:"Bad Request",
  401:"Unauthorized",
  402:"Payment Required",
  403:"Forbidden",
  404:"Not Found",
  405:"Method Not Allowed",
  406:"Not Acceptable  ",
  407:"Proxy Authentication Required",
  408:"Request Time-out",
  409:"Conflict",
  410:"Gone",
  411:"Length Required",
  412:"Precondition Failed",
  413:"Request Entity Too Large",
  414:"Request-URI Too Large",
  415:"Unsupported Media Type",
  416:"Requested range not satisfiable",
  417:"Expectation Failed",
  500:"Internal Server Error",
  501:"Not Implemented",
  502:"Bad Gateway",
  503:"Service Unavailable",
  504:"Gateway Time-out",
  505:"HTTP Version not supported"
};

##register reason_phrase : int -> string
##args(code)
{
  return (code in reason_phrase_map) ? reason_phrase_map[code] : "reason_phrase";
}

##endmodule

exports.status_code = BslNet_Requestdef_status_code
exports.reason_phrase = BslNet_Requestdef_reason_phrase

