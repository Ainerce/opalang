/*
    Copyright Â© 2011 MLstate

    This file is part of OPA.

    OPA is free software: you can redistribute it and/or modify it under
    the terms of the GNU Affero General Public License, version 3, as
    published by the Free Software Foundation.

    OPA is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
    License for more details.

    You should have received a copy of the GNU Affero General Public
    License along with OPA. If not, see <http://www.gnu.org/licenses/>.
*/

var net = require('net');

##opa-type outcome('a, 'b)

##extern-type continuation('a)
##extern-type SSL.secure_type

// A record containing:
//   connection: The connection object returned by net.connect
//   id: The unique connection id
//   has_connected: Whether the connection was already established
//   closed: Flag that indicates whether the connection has been closed
//   data: An array of received data waiting to be read
//   error: A possible connection error
//   cont_read_plain: A continuation waiting for incoming data
//   cont_read_outcome: A continuation waiting for incoming data or an error
##extern-type Socket.connection

function connect_common(addr, port, cont, with_err_cont) {

    var connection_info = {
        connection: net.connect(port, addr),
        id: Math.floor(Math.random() * 1024 * 1024 * 1024 * 4),
        has_connected: false,
        closed: false,
        data: [],
        error: null,
        cont_read_plain: null,
        cont_read_outcome: null
    };

    connection_info.connection.on('connect', function () {
        connection_info.has_connected = true;
        if (with_err_cont) {
            // Continuation expects an outcome, so we must wrap the value
            return_(cont, js_success(connection_info));
        } else {
            // Assume that no errors occur, so we send just the
            // plain value
            return_(cont, connection_info);
        }
    });

    connection_info.connection.on('data', function (data) {

        // Disable existing timeout
        connection_info.connection.setTimeout(0);

        if (connection_info.cont_read_plain) {
            var c = connection_info.cont_read_plain;
            connection_info.cont_read_plain = null;
            return_(c, data.toString());
        } else if (connection_info.cont_read_outcome) {
            var c = connection_info.cont_read_outcome;
            connection_info.cont_read_outcome = null;
            return_(c, js_success(data.toString()));
        } else {
            connection_info.data.push(data);
        }

    });

    connection_info.connection.on('error', function (err) {

        // Ditto
        connection_info.connection.setTimeout(0);

        if (!connection_info.has_connected && with_err_cont) {
            // Since we couldn't even establish the connection, we
            // need to signal the caller if it wants to handle errors
            return_(cont, js_failure(err.toString()));
        } else if (connection_info.cont_read_outcome) {
            var c = connection_info.cont_read_outcome;
            connection_info.cont_read_outcome = null;
            return_(c, err.toString());
        } else {
            connection_info.error = err;
        }

    });

    connection_info.connection.on('close', function (had_error) {
        connection_info.closed = true;
    });

    return js_void;

}

##register [cps-bypass] connect: string, int,\
                                 continuation(Socket.connection) -> void
##args(addr, port, cont)
{
    return connect_common(addr, port, cont, false);
}

##register [cps-bypass] secure_connect: string, int, SSL.secure_type,\
                                        continuation(Socket.connection) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect() is not implemented");
}

##register [cps-bypass] connect_with_err_cont: string, int,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, cont)
{
    return connect_common(addr, port, cont, true);
}

##register [cps-bypass] secure_connect_with_err_cont: string, int, SSL.secure_type,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect_with_err_cont() is not implemented");
}

##register close: Socket.connection -> void
##args(connection_info)
{
    connection_info.connection.end();
    return js_void;
}

##register [cps-bypass] write: Socket.connection, string,\
                               continuation(int) -> void
##args(connection_info, data, cont)
{
    connection_info.connection.write(data, 'binary', function () {
        // TODO: figure out how much was actually written
        return_(cont, data.length);
    });

    return js_void;
}

##register [cps-bypass] write_with_err_cont: Socket.connection, int, string,\
                               continuation(outcome(int,string)) -> void
##args(conection_info, timeout, data, cont)
{
    error("write_with_err_cont() is not implemented");
}

##register [cps-bypass] write_len: Socket.connection, string, int,\
                               continuation(int) -> void
##args(connection_info, data, len, cont)
{
    error("write_len() is not implemented");
}

##register [cps-bypass] write_len_with_err_cont: Socket.connection, int, string, int,\
                               continuation(outcome(int,string)) -> void
##args(connection_info, timeout, data, len, cont)
{
    error("write_len_with_err_cont() is not implemented");
}

##register [cps-bypass] read : Socket.connection, continuation(string) -> void
##args(connection_info, cont)
{
    if (connection_info.closed) {
        // Arbitrarily return empty string
        return return_(cont, "");
    } else if (connection_info.data.length == 0) {
        // Needs to wait for data
        connection_info.cont_read_plain = cont;
        return js_void;
    }
    var res = connection_info.data.join("");
    connection_info.data = [];
    return return_(cont, res);
}

##register [cps-bypass] read_with_err_cont : \
    Socket.connection, int, continuation(outcome(string,string)) -> void
##args(connection_info, timeout, cont)
{

    if (connection_info.closed) {
        return return_(cont, js_failure("socked closed"));
    } else if (connection_info.data.length != 0) {
        var res = connection_info.data.join("");
        connection_info.data = [];
        return return_(cont, js_success(res));
    } else if (connection_info.error) {
        var e = connection_info.error.toString();
        connection_info.error = null;
        return return_(cont, js_failure(e));
    }

    // Needs to wait

    connection_info.cont_read_outcome = cont;

    connection_info.connection.setTimeout(timeout, function () {
        connection_info.cont_read_outcome = null;
        connection_info.connection.end();
        return return_(cont, js_failure("timeout"));
    });

    return js_void;
}

##register conn_id : Socket.connection -> int
##args(connection_info)
{
    return connection_info.id;
}

