/*
    Copyright Â© 2011 MLstate

    This file is part of OPA.

    OPA is free software: you can redistribute it and/or modify it under
    the terms of the GNU Affero General Public License, version 3, as
    published by the Free Software Foundation.

    OPA is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
    License for more details.

    You should have received a copy of the GNU Affero General Public
    License along with OPA. If not, see <http://www.gnu.org/licenses/>.
*/

var net = require('net');

##opa-type outcome('a, 'b)

##extern-type continuation('a)
##extern-type SSL.secure_type

// A record containing:
//   connection: The connection object returned by net.connect
//   id: The unique connection id
//   has_connected: Whether the connection was already established
//   closed: Flag that indicates whether the connection has been closed
//   data: An array of received data waiting to be read
//   error: A possible connection error
//   read_callback: A continuation waiting for incoming data or an error
//   write_callback: A continuation waiting for the end of an write or an error
##extern-type Socket.connection

function unregister_and_call(obj, field, value) {
    var callback = obj[field];
    obj[field] = null;
    callback(value);
}

function callback_plain(cont, message) {

    return function (data) {
        if ('success' in data) {
            return_(cont, data.success);
        } else { // data.failure
            error(message + ": " + data.failure);
        }
        return js_void;
    }

}

function callback_with_err_cont(cont) {

    return function (data) {
        if ('success' in data) {
            return_(cont, js_success(data.success));
        } else { // data.failure
            return_(cont, js_failure(data.failure));
        }
        return js_void;
    }

}

function connect_common(addr, port, callback) {

    var connection_info = {
        connection: net.connect(port, addr),
        id: Math.floor(Math.random() * 1024 * 1024 * 1024 * 4),
        has_connected: false,
        closed: false,
        data: [],
        error: null,
        read_callback: null,
        write_callback: null
    };

    connection_info.connection.on('connect', function () {
        connection_info.has_connected = true;
        callback({success: connection_info});
    });

    connection_info.connection.on('data', function (data) {

        // Disable existing timeout
        connection_info.connection.setTimeout(0);

        if (connection_info.read_callback) {
            unregister_and_call(connection_info, 'read_callback',
                                {success: data.toString()});
        } else {
            connection_info.data.push(data);
        }

    });

    connection_info.connection.on('error', function (err) {

        // Ditto
        connection_info.connection.setTimeout(0);

        // The error raised by node can be treated by several different
        // Opa functions. Thus, we must find out who is expecting
        // an outcome and direct the error there.

        var wrapped_err = {failure: err.toString()};

        if (!connection_info.has_connected) {
            // Since we couldn't even establish the connection, we
            // need to signal the caller.
            callback(wrapped_err);
        } else if (connection_info.read_callback) {
            unregister_and_call(connection_info, 'read_callback', wrapped_err);
        } else if (connection_info.write_callback) {
            unregister_and_call(connection_info, 'write_callback', wrapped_err);
        } else {
            // We keep the error if somebody needs it later
            connection_info.error = err;
        }

    });

    connection_info.connection.on('close', function (had_error) {
        connection_info.closed = true;
    });

    return js_void;

}

##register [cps-bypass] connect: string, int,\
                                 continuation(Socket.connection) -> void
##args(addr, port, cont)
{
    return connect_common(addr, port,
                          callback_plain(cont, "Connection failed"));
}

##register [cps-bypass] secure_connect: string, int, SSL.secure_type,\
                                        continuation(Socket.connection) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect() is not implemented");
}

##register [cps-bypass] connect_with_err_cont: string, int,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, cont)
{
    return connect_common(addr, port,
                          callback_with_err_cont(cont));
}

##register [cps-bypass] secure_connect_with_err_cont: string, int, SSL.secure_type,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect_with_err_cont() is not implemented");
}

##register close: Socket.connection -> void
##args(connection_info)
{
    connection_info.connection.end();
    return js_void;
}

function write_common(connection_info, data, timeout, callback) {

    if (connection_info.closed) {
        return callback({failure: 'socked closed'});
    }

    connection_info.write_callback = callback;

    // Since these writes in Opa are blocking, we can assume that
    // this value won't change before the current write. However,
    // we still need to check what causes this variable to be
    // updated.
    var b = connection_info.connection.bytesWritten;

    connection_info.connection.write(data, 'binary', function () {
        // FIXME: What happens if part of the write goes through when
        // we hit a timeout?
        if (connection_info.write_callback) {
            var bytes_written = connection_info.connection.bytesWritten - b;
            unregister_and_call(connection_info, 'write_callback',
                                {success: bytes_written});
        }
    });

    if (timeout != null) {
        connection_info.connection.setTimeout(timeout, function () {
            unregister_and_call(connection_info, 'write_callback',
                                {failure: 'timeout'});
        });
    }

    return js_void;

}

##register [cps-bypass] write: Socket.connection, string,\
                               continuation(int) -> void
##args(connection_info, data, cont)
{
    return write_common(connection_info, data, null,
                        callback_plain(cont, "Write failed"));
}

##register [cps-bypass] write_with_err_cont: Socket.connection, int, string,\
                               continuation(outcome(int,string)) -> void
##args(conection_info, timeout, data, cont)
{
    return write_common(connection_info, data, timeout,
                        callback_with_err_cont(cont));
}

##register [cps-bypass] write_len: Socket.connection, string, int,\
                               continuation(int) -> void
##args(connection_info, data, len, cont)
{
    error("write_len() is not implemented");
}

##register [cps-bypass] write_len_with_err_cont: Socket.connection, int, string, int,\
                               continuation(outcome(int,string)) -> void
##args(connection_info, timeout, data, len, cont)
{
    error("write_len_with_err_cont() is not implemented");
}

function read_common(connection_info, timeout, callback) {

    if (connection_info.closed) {
        return callback({failure: 'socket closed'});
    } else if (connection_info.data.length != 0) {
        var res = connection_info.data.join('');
        connection_info.data = [];
        return callback({success: res});
    } else if (connection_info.error) {
        var res = connection_info.error.toString();
        connection_info.error = null;
        return callback({failure: res});
    }

    // Needs to wait for an outcome

    connection_info.read_callback = callback;

    if (timeout != null) {
        connection_info.connection.setTimeout(timeout, function () {
            unregister_and_call(connection_info, 'read_callback',
                                {failure: 'timeout'});
        });
    }

    return js_void;

}

##register [cps-bypass] read : Socket.connection, continuation(string) -> void
##args(connection_info, cont)
{
    return read_common(connection_info, null,
                       callback_plain(cont, 'Read failed'));
}

##register [cps-bypass] read_with_err_cont : \
    Socket.connection, int, continuation(outcome(string,string)) -> void
##args(connection_info, timeout, cont)
{
    return read_common(connection_info, timeout,
                       callback_with_err_cont(cont));
}

##register conn_id : Socket.connection -> int
##args(connection_info)
{
    return connection_info.id;
}

