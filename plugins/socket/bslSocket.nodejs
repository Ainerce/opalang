/*
    Copyright Â© 2011 MLstate

    This file is part of OPA.

    OPA is free software: you can redistribute it and/or modify it under
    the terms of the GNU Affero General Public License, version 3, as
    published by the Free Software Foundation.

    OPA is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
    License for more details.

    You should have received a copy of the GNU Affero General Public
    License along with OPA. If not, see <http://www.gnu.org/licenses/>.
*/

var net = require('net');

##opa-type outcome('a, 'b)

##extern-type continuation('a)
##extern-type SSL.secure_type

// A record containing:
// - The connection object returned by net.connect
// - The unique connection id
// - An array of received data
// - An optional continuation waiting for incoming data
##extern-type Socket.connection

##register [cps-bypass] connect: string, int,\
                                 continuation(Socket.connection) -> void
##args(addr, port, cont)
{

    // Invariant: either data is empty or cont is null
    var connection_info = {
        id: Math.floor(Math.random() * 1024 * 1024 * 1024 * 4),
        data: [],
        error: null,
        cont_read_plain: null,
        cont_read_outcome: null
    };

    connection_info.connection = net.connect(port, addr, function () {
        return_(cont, connection_info);
    });

    connection_info.connection.on('data', function (data) {

        // Disable existing timeout
        connection_info.connection.setTimeout(0);

        if (connection_info.cont_read_plain) {
            var c = connection_info.cont_read_plain;
            connection_info.cont_read_plain = null;
            return_(c, data.toString());
        } else if (connection_info.cont_read_outcome) {
            var c = connection_info.cont_read_outcome;
            connection_info.cont_read_outcome = null;
            return_(c, js_success(data.toString()));
        } else {
            connection_info.data.push(data);
        }

    });

    connection_info.connection.on('error', function (err) {

        // Ditto
        connection_info.connection.setTimeout(0);

        if (connection_info.cont_read_outcome) {
            var c = connection_info.cont_read_outcome;
            connection_info.cont_read_outcome = null;
            return_(c, err.toString());
        } else {
            connection_info.error = err;
        }

    });

    return js_void;
}

##register [cps-bypass] secure_connect: string, int, SSL.secure_type,\
                                        continuation(Socket.connection) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect() is not implemented");
}

##register [cps-bypass] connect_with_err_cont: string, int,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, cont)
{
    error("connect_with_err_cont() is not implemented");
}

##register [cps-bypass] secure_connect_with_err_cont: string, int, SSL.secure_type,\
                                 continuation(outcome(Socket.connection,string)) -> void
##args(addr, port, secure_type, cont)
{
    error("secure_connect_with_err_cont() is not implemented");
}

##register close: Socket.connection -> void
##args(connection_info)
{
    connection_info.connection.end();
    return js_void;
}

##register [cps-bypass] write: Socket.connection, string,\
                               continuation(int) -> void
##args(connection_info, data, cont)
{
    connection_info.connection.write(data, 'binary', function () {
        // TODO: figure out how much was actually written
        return_(cont, data.length);
    });

    return js_void;
}

##register [cps-bypass] write_with_err_cont: Socket.connection, int, string,\
                               continuation(outcome(int,string)) -> void
##args(conection_info, timeout, data, cont)
{
    error("write_with_err_cont() is not implemented");
}

##register [cps-bypass] write_len: Socket.connection, string, int,\
                               continuation(int) -> void
##args(connection_info, data, len, cont)
{
    error("write_len() is not implemented");
}

##register [cps-bypass] write_len_with_err_cont: Socket.connection, int, string, int,\
                               continuation(outcome(int,string)) -> void
##args(connection_info, timeout, data, len, cont)
{
    error("write_len_with_err_cont() is not implemented");
}

##register [cps-bypass] read : Socket.connection, continuation(string) -> void
##args(connection_info, cont)
{
    if (connection_info.data.length == 0) {
        // Needs to wait for data
        connection_info.cont_read_plain = cont;
        return js_void;
    }
    var res = connection_info.data.join("");
    connection_info.data = [];
    return return_(cont, res);
}

##register [cps-bypass] read_with_err_cont : \
    Socket.connection, int, continuation(outcome(string,string)) -> void
##args(connection_info, timeout, cont)
{
    if (connection_info.data.length != 0) {
        var res = connection_info.data.join("");
        connection_info.data = [];
        return return_(cont, js_success(res));
    } else if (connection_info.error) {
        var e = connection_info.error.toString();
        connection_info.error = null;
        return return_(cont, js_failure(e));
    }

    // Needs to wait

    connection_info.cont_read_outcome = cont;

    connection_info.connection.setTimeout(timeout, function () {
        connection_info.cont_read_outcome = null;
        return return_(cont, js_failure("timeout"));
    });

    return js_void;
}

##register conn_id : Socket.connection -> int
##args(connection_info)
{
    return connection_info.id;
}

